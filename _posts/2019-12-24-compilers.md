---
layout: post
title: "Compilers"
---

I am not a compiler expert.

Throughout my career, I have come to realize a phenomenon: people who have done "compiler" work, even if it was just a little, easily develop a superior attitude, leading to various problems when working with others. They often harbor dogmatic and idealistic views, and in the process of worsening interpersonal relationships, they may also design unreasonable software architectures, wasting vast amounts of human and material resources.

The DSL example I mentioned earlier involved two such people. They both claimed to be compiler experts, constantly boasting and debating in front of me, even arguing about the most fundamental concepts in a showy "educating" manner. In reality, only one of them had done parser work, and neither of them had truly done compiler work. The first one acted like a philosopher, stroking his beard and nodding slowly, while the second one was completely clueless, constantly using jargon but having no idea what he was talking about, yet still acting arrogant.

I was brought into this company as an expert by these people, but upon arrival, I found that they enjoyed showing off their "expertise" in front of me. They even asked me questions, but every time I spoke, I found that they weren't really interested in the answers, as they seemed more interested in appearing smarter than others.

Despite their arrogant demeanor and self-proclaimed omniscience, they were submissive and fawning towards powerful figures like Brendan Eich, the creator of JavaScript. However, it was clear that Brendan Eich was a dabbler when it came to language design, and even those with a modest understanding of languages would not show deference to such individuals."Yin, do you know X?" He hoped you wouldn't know, so he could explain this new term he had just learned for hours. Every time this happened, I would recall a former colleague's favorite saying: "You ask me because you don't know, or because you do?" In truth, the concept X was one I had been enthusiastic about and experimented with many years ago, only to discover serious issues and abandon it.

Matter gets worse, as this person was a die-hard fan of Haskell. He always harbored such grand ambitions, wanting to rewrite the entire company's code using "pure functional programming."

Dealing with such people is frustrating, to what extent? They often try to rewrite the company's code using a new language (Scala, Go, etc.), only to start criticizing it a month later, abandoning the project two months in, and the code disappearing without a trace. They then switch to another language, repeating the cycle.

Eventually, they made no progress and came up with the idea of creating a DSL, causing turmoil within the team. Experienced engineers, including myself and an early Netscape veteran, strongly opposed, proposing simpler, more efficient solutions. However, due to the management's lack of understanding, they were allowed to go ahead. Since I was tired of their grandstanding about the DSL in front of me, I decided to switch departments and no longer deal with language and compiler-related matters.

Now, this DSL has been around for several years, yet it remains garbage. Amazingly, the company even hired a senior Java figure to write a specification for it. These two individuals have since been promoted to Principal Engineer and Distinguished Engineer. When I saw the "Distinguished Engineer" title, I couldn't help but laugh. I'm sure experienced PL people will understand the issues with this DSL. I imagine the conflict between this Java person and these two. If he's indifferent, then his expertise is certainly worth questioning. At Coverity and other companies, the issues with compiler engineers are generally similar. They unconsciously consider themselves as elite programmers, so they display a haughty demeanor towards others.

Coverity has an engineer named ABC, who has written more comprehensive static analysis and is familiar with C++. He is always arrogant towards others and even directly tells others, "What kind of code is this? I would never write such crappy code!" There is also a PhD graduate from Stanford Compiler Professor Alex Aiken, working as an architect at Coverity. He hardly writes or looks at other people's code, and cannot provide deep insights because he is detached from practical engineering, only issuing orders. The most distinguished engineer, he spends his days in a lofty manner, seemingly making parser his lifelong research focus, but doing little actual work.

In every company I have worked for, if the work involves compilers, there are always such people. I won't go into detail about others.

Some American companies state that they are cautious about resumes mentioning "compiler experience," even going so far as to say, "We don't hire compiler specialists." I have also been filtered out because I have done compiler-related work. Compiler specialists can do ordinary programming jobs, so why do some companies explicitly refuse to hire them? I now understand why, as those who consider themselves "compiler specialists" are likely to have poor teamwork skills, enjoy displaying a superior and savior attitude, and cannot treat others equally and respectfully.

Some people call me a "compiler expert," and like to mention the word "compiler" in my presence. I have always found this uncomfortable, but I have never formally refused this title. Every time I encounter a "real" compiler expert, I always feel like I'm not part of that circle. It's not that I can't do compiler work, but the understanding, ideas, and attitudes of compiler domain experts don't align with mine. I should make it clear: I am not a compiler expert, and I don't hold the field in high regard. I generally don't look down on others, but when it comes to shallow-minded people who think highly of themselves, I do express a dismissive attitude. Regarding my field of study, I am a programming language (PL) researcher. From a broader perspective, I am a computer scientist. People often confuse PL and compilers as the same field, but they are very different. A person who truly understands PL can handle compiler work fairly well, but a compiler expert may not necessarily understand PL. Why is that? Because PL research covers the most fundamental principles, explaining not only the semantics of the language but also the architecture and working principles of processors. It can also explain how compilers work, as a compiler is simply translating the semantics of one language into another. The programming paradigms and techniques used in PL research can be applied to compiler construction, but the scope of compiler expertise is much more limited.

Those who have delved into PL can see what's going on at a fundamental level in compilers. Compilers are, in a way, an application of PL thought, but the applications of PL go far beyond compilers. Every time someone calls me a compiler expert, I feel belittled. I may have applied the essence of my ideas and adapted them, doing some compiler work, but I am not limited to this direction.

People who specialize in compilers typically focus on "implementing" languages that have already been designed, such as C or C++. They must write compilers according to the language specifications written by language designers, leaving no room for creativity or understanding of the intricacies of language design. Many compiler engineers are not self-taught, but rather modify existing compilers, so they are often limited by the specific architectures that already exist. Few compiler engineers have completely implemented a language from scratch, most make small changes and optimizations on existing foundations. This significantly limits their global understanding.

Many compiler engineers have not received systematic PL (Programming Languages) education, some not even touching compilers in school, let alone studying PL. For instance, at my first company Coverity, many of the people recruited had never worked with compilers and did not understand PL. I joined not long ago, and Coverity's VP boasted to new hires: “We will teach you everything!” Unfortunately, the essence of PL cannot be taught by a company in the short term. Coverity, Google, Facebook, Intel, Microsoft... none of them have this ability.

Many half-baked compiler workers believe that by following projects in companies and tinkering with LLVM and the like, they will understand all the principles. However, the fact is that many people have done this for ten years or more and still do not understand the most fundamental principles, as they are limited in their imagination by the specific implementations. PL theory is connected to the essence of computation, and without understanding these principles, one can only see the surface and memorize, unable to understand new phenomena. In conversations with LLVM experts, I often find that their knowledge is stagnant, frozen in the specific implementation of LLVM.

Due to the lack of in-depth research into PL theory, compiler engineers often view languages through the perspective of a frog at the bottom of a well, believing that the language they have implemented (such as C++) is the only one. Why is a language designed in such a way? They don't know. How could it be improved? They don't know. "It's just like that!" is a common phrase from compiler engineers. Of course, many compiler engineers cannot even fully implement C++ and have only made very small changes to existing foundations.

Many compiler engineers revere Bjarne Stroustrup as a deity, but they do not know that Stroustrup is not a shining star in the PL field. Stroustrup visited IU in November 2011 to give a talk on C++11, and IU's veteran PL professors were all in attendance. Stroustrup humbly said: “I need to learn a lot from you to improve C++.” It seems "humble," but he was actually speaking the truth, as IU's professors were indeed stronger in language design than he was. I didn't see anything innovative in Stroustrup's entire speech, all of it was things I had been using for decades. However, the improvements to C++ were considered major historical breakthroughs by compiler people because many of them had never used other languages or even knew they existed.

Later, one of my weaker PL (Programming Language) classmates joined the C++ committee to make some improvements. From her descriptions and demeanor, I felt the C++ committee atmosphere was quite bureaucratic, rigid, and shallow. After she joined the C++ committee, she seemed to have lost her mind, making a big deal out of trivial matters, as if it were some major breakthrough. Some skilled PL people rarely join the C++ committee because it means using other people's networks and putting up with people they look down upon, requiring them to do meaningless tasks first.

The masters revered by compiler people are not considered much in the eyes of real PL researchers. The gap in perception between compiler people and PL researchers is quite apparent. PL people, because they understand many things, are humble and usually don't want to expose the gap. But compiler people, due to their position in the industry, act arrogant and believe they understand everything, only to be confused when faced with profound PL issues.

Compiling is a tedious job, mostly translating other people's languages into another person's hardware instructions. The compiler domain lies between the two realms of programming languages and computer architecture, with the language above unable to be changed and the instructions below unable to be changed, leaving limited creative space.

The compiler domain has been going over the same programming patterns and techniques for decades, and it gets old quickly. Initially, it seemed new and exciting, but after getting familiar with it, it became the same old thing. Many programmers know how to avoid "low-level repetition," but due to not having systematically learned compilers, they often mistakenly believe that compiler work is more advanced and interesting, while in reality, the compiler domain is more prone to low-level repetition due to its limited creative space.: The same compilation optimization techniques are used to create compilers for language A in Company A, then for language B in Company B, and so on. With some luck, you might encounter C, C++, Java. With bad luck, you might encounter JavaScript, PHP, Ruby, Go, or some strange DSL. Regardless of how flawed the language design is or how complicated the hardware instruction design is, the compiled instructions must be able to correctly run all the code written in that language. Is this not a daunting task?

During my time at Cornell, there was a very influential compiler professor who had never published any theoretically valuable papers, yet he wrote numerous articles about Java. He and his PhD students would always bring some "new features" from other languages decades old and transplant them into Java, repackaging old wine in new bottles and publishing papers to secure funding. Due to the large amount of funding they received, they were well-received in the department, and his students would carry themselves with an arrogant demeanor in front of others.

Later, one of his students went to Facebook and worked on HipHop, a "compiler" from PHP to C++. This "source-to-source" compiler wasn't particularly difficult to create, but compiling for PHP, which is of poor quality, was a laborious and painful process. There was no theoretical value to mention, let alone any value in industry. One of my former colleagues once made a sharp and humorous critique of Facebook's project: "Facebook now not only paints pigs with lipstick, but it's starting to f... it!"

Following that, there were things like PHP VMs, which were increasingly bizarre. Later, this student might have grown tired of it and switched to doing things unrelated to language development. In the PL researcher's perspective, VMs were not particularly surprising. The PL field has various "abstract machines" (abstract machines), such as the CEK machine, which reveal many aspects of computation. I myself have designed and implemented several "reversible abstract machines," which can perform so-called "reversible computation." So, a PL researcher can easily design a VM, as they are simply a type of optimized interpreter.

Every time I see a compiler engineer talking about "VM" with a reverent and proud expression, as if only they understand what a VM is, I find it amusing, along with an inexplicable taste. Compiler engineers may know how to implement a specific VM and be familiar with some dry details and terminology, but they don't understand the essence of a VM or how to design a new, feature-rich VM. In "The Legend of Chez Scheme," I mentioned in passing that I once took a compiler course at Cornell and dropped it halfway through. Looking back on this history now, I find it quite inspiring in terms of "education philosophy." What is education, for what purpose? Cornell's this course provided me with a great counterexample.

The professor for this compiler course that year was Tim Teitelbaum, who was also the co-founder of GrammaTech. GrammaTech is similar to Coverity in that it's a static analysis tool, but GrammaTech can analyze binary code. Tim Teitelbaum was a devotee of Donald Knuth. He frequently extolled Knuth's "great ideas," such as attribute grammar. He always spoke of Knuth's things as the greatest inventions.

It's unclear who originally designed this course. Andrew Myers and Tim Teitelbaum used to take turns teaching it.

So why did I drop this course, and that too after the school's deadline for dropping courses? Because its educational philosophy was quite outdated and irrational, to put it mildly.

From the course outline, you can see that it was a very traditional compiler course. It spent a lot of time and effort at the outset on wrestling with parsers. The source language was a language similar to Java, and the parser was generated using tools like lex and yacc. This blind reverence for parsers, which I had criticized in another article, was not even my main point of contempt. I was shocked when I received the grade for that assignment. I had completed the parser and started compiling the code for the first pass. When I saw the score, I was stunned. I had never received such a poor grade before! Upon closer inspection, I realized that the code I had submitted was being run through tests that I was unaware of. The grader simply gave out scores based on the results of these tests.

The assignment itself required writing a compiler from scratch with no framework or example code. After much effort, I wrote a compiler and even wrote some small tests myself, believing I had met the requirements. However, my compiler code was then subjected to a suite of tests I had no access to. Therefore, I was surprised to find that many of my tests had failed.

The most frustrating part was that students did not have access to these tests and they were not provided. This meant that when submitting the assignment, I could not run the tests that would be used to grade it, leaving me in the dark about how many tests would fail.

When I protested to the TA and professor, explaining that this was unfair and that I should be given access to the tests, I was met with harsh rejection and disdain. It was as if I was being labeled an unworthy student for making such unreasonable demands. How could the tests used for grading be given to me? Was I really that stupid?

Many other Cornell students were treated similarly, perhaps thinking it was no big deal, but this was completely unreasonable. According to sound teaching principles, students should be entitled to feedback on their learning status. If students are given programming assignments, they should be able to receive feedback based on actual testing, to determine if their compiler meets the requirements. Keeping the tests hidden was equivalent to not providing clear requirements, and then using that hidden test suite to give the grade.: The course was supposed to provide tests along with English descriptions for students, but they only ran all the tests themselves and submitted the code afterwards. This way, students could accurately grasp the requirements of the assignment instead of guessing from confusing English paragraphs.

However, due to the arrogant attitudes of the professors and TAs, I ultimately decided to drop the course when it was almost halfway through. Of course, to perform this action required the dean's approval, so I left a "black mark" with the dean.

In my opinion, Cornell professors' behavior is not qualified for educators; they can be considered as swindling, bullying, and harming students. In their view, education is one-sided, and students must pass assignments and exams, while professors are not responsible for teaching methods. They can teach however they want, and the assignments and exams can be manipulated as they wish.

Many Cornell professors exhibit similar phenomena, with no concern for students' lives, only focused on securing funding and flaunting their power. Perhaps this is why Cornell has had students committing suicide. A year after I left, within a week, three students jumped off the suspension bridge near the campus to commit suicide, causing a sensation in the United States.

Later, on the internet, someone criticized Cornell, saying: "Cornell wants to teach you swimming, so it pushes you into the pool, waiting for you to struggle up. When you're almost there, it throws a big rock at you, then waits for you to swim up again. When you're almost there again, it grabs a rake and hits your head hard. This way, you can die, but Cornell is still waiting for you to swim up to the shore...": This passage accurately described my experience at Cornell.

Transferring to IU, I joined Kent Dybvig's compiler course and discovered that the compiler course I had imagined already existed and was implemented so warmly by him. In each compiler pass, he gave all the "official tests" to students. Students were required to implement each compiler pass, run all tests on their own computers, thoroughly check, and then submit the assignments. Moreover, the submission website automatically tested the submitted code and gave feedback at the time of submission: "You have N tests that failed, please correct and resubmit."

This is the correct educational method because it provides students with reasonable feedback, making it clear whether their performance meets expectations, encouraging progress, rather than giving arbitrary grades based on unknown standards.

Cornell didn't understand the purpose of education was to cultivate people, not just to issue degrees. Dybvig professor not only had a high level of technology and academics, but his course was also designed so scientifically and friendly. He was a true educator.

Although compiler engineers are often arrogant, they often overestimate their position in the entire IT industry compared to other programmers. Compiler engineers often think they understand everything about programming languages, but in fact, they are only half-knowledgeable. I consider the most important textbooks in the compiler domain, "Dragon Book" and "Tiger Book," to have a lot of half-baked content in my opinion, with authors who are not clear themselves. They spent a lot of space on the seemingly profound but in fact shallow topic of parsing, wasting readers' time and misleading them into believing that parsing is the most crucial technology. As a result, many people finish compiler courses only knowing how to write parsers but unable to understand the truly essential parts. "Dragon Book" is difficult to read, why is that? Because the authors themselves don't fully understand it. "Tiger Book" claims to have improved upon "Dragon Book," but it's still difficult to read, feeling like just a new cover.

I once collaborated with a disciple of "Tiger Book" author Andrew Appel when he was an assistant professor at IU. Using an opportunity for an independent study, he forced me to write a meaningless paper, and he was very pushy and insincere towards people. As a PhD graduate from Princeton University, his scholarly level was below that of other IU professors, but he displayed various "low" behavior towards compiler experts, constantly showing off that he had worked with certain people in the past. That was the most uncomfortable semester I spent at IU, deepening my bias against "compiler people."

The top figures in the compiler domain behave this way, and other people who claim to have done compilers can imagine the rest. Most people who claim to have done compilers probably can't write a basic compiler from scratch. Using LLVM's existing framework for some optimization and calling themselves compiler developers. Many compiler experts are memorizing books rigidly, shallowly memorizing terms (like SSA), and memorizing the specific implementation details (like LLVM's IR), unable to see through, and unable to adapt.

That's why I often say that compilers are the most dead knowledge and the most rigidly doctrinaire field in computer science. People often come up with an approach, give it a name, and others follow suit, memorizing it rigidly, and the name is called loudly. If you forget the meaning of the name at a given moment, you'll be labeled as not knowing Napoleon, not knowing Mao Zedong. You're not a compiler developer!

Nowadays, due to the AI bubble, many people are turning to so-called "AI frameworks," "AI compilers." These positions are so numerous that many people have never even encountered compilers and have become "depth learning compiler engineers" instead. Half-baked "AI framework engineers" and "AI compiler engineers" argue and optimize on others' frameworks, believing they are pioneering work in the world, unaware that those things can be easily penetrated by those who delve deep into PL. Many AI framework engineers use strange terminology, yet they cannot comprehend that an "AI framework" is merely a "differentiable programming language," and they fail to approach problems from the perspective of high-level languages and logic.

The principles and essence of AI frameworks and compilers can be easily explained by PL theory, and PL researchers can provide the correct direction for these projects, preventing unnecessary detours. However, these self-proclaimed "compiler engineers" in the AI field are oblivious to this. Arrogant and revering authority, they even believe they can "educate" those who understand less than they do.

Every large company wants to jump on the AI bandwagon and create their own "AI framework" and "AI compiler," fearing losing face in the industry if they don't. They hire famous AI framework experts to represent their company, not knowing what they will ultimately produce. All AI frameworks and compilers are essentially the same, amounting to redundant labor. Some people tinker with one framework and then another using the same techniques, with engineering tasks in between that are mundane. These situations are truly boring.

The AI craze is losing steam, and most AI companies will fail within a year. The work on "AI compilers" is also nearing extinction. So let them stumble around blindly; after all, they won't last long.

This is why, despite multiple compiler-related job opportunities, including Apple's LLVM department, I ultimately didn't take any of them. When I joined Intel, the compiler department welcomed me, but after careful consideration, I chose another direction. I clearly remember that every time I did compiler-related work, it was extremely oppressive, requiring me to face some dull and self-important people, and the content was repetitive, mundane, and tedious. I only respect the author of compilers, Kent Dybvig. However, I don't want to work with him on compilers. Recently, many chip companies' "AI compiler" departments have approached me, and I turned them all down. I don't like being surrounded by these people and doing these things. I'd rather sell pastries than work on compilers.

Due to the personality traits of compiler engineers, it is important for companies, except those specializing in compilers, to understand their personality, attitude, and work style during interviews. They should be able to remain indifferent to these, treat others equally, and be rational and straightforward in engineering matters. Otherwise, a self-important "compiler engineer" joining the team could become a disaster.

I wrote this article to warn the broad IT industry and to mentally support other programmers. I hope they won't be misled by the "difficulty" of compilers or intimidated or pressured by compiler engineers. What you do isn't lower or more mundane work. Quite the opposite, the space for creativity lies not in low-level compiler-type things but closer to applications and reality.

Every time someone tells me that compilers are profoundly complex but they yearn for it yet can't reach it, I give them an analogy: making compilers is like making knives. You can make excellent knives, but you're still just a blacksmith. A blacksmith doesn't know how to make five-star gourmet dishes using these knives, creating dishes that delight the heart and soul, because that's the chef's job. You can choose to make knives or cook; there's no hierarchy in that choice.