---
layout: post
title: "smart-contract"
---

I mentioned in a previous article about artificial intelligence that "automatic programming" is impossible. Today, I want to discuss a related topic: formal verification of Ethereum-style smart contracts using Hoare Logic. Some people claim to implement formal verification of smart contracts based on "deep learning," which is used to automatically ensure the contract's correctness. One method is using "deep learning," which generates Hoare Logic's "preconditions" and "postconditions" after training.

### Hoare Logic

Let's clarify Hoare Logic first. Hoare Logic is a method for formal verification, used to verify the correctness of programs. It works by annotating code with certain "pre-conditions" and "post-conditions" (pre-condition and post-condition), then logical reasoning can be performed to validate some basic properties of the code, such as the correctness of the balance after a transfer.

For example, in Hoare Logic:

{x=0} x:=x+1 {x>0}

This means that if x is initially equal to 0, then after executing x:=x+1, x should be greater than 0. The pre-condition here is x=0, and the post-condition is x > 0. If x initially equals 0, then after executing x:=x+1, x will indeed be greater than 0, so this statement passes the verification.

The Hoare Logic system connects all these pre- and post-conditions with the code and, through logical derivation, makes the following guarantee: under the condition that the pre-condition holds, the execution of the code ensures that the post-condition is true. If all these conditions are met, the system considers this to be a "correct program". Note that the so-called "correct" here is entirely determined by humans, and the system does not know what "correct" means.: Hoare Logic can indeed have an effect on a program's safety, it has been applied to some practical projects. For instance, in the code of Microsoft Windows drivers, there is a "safe annotation language" called SAL, which is an implementation of Hoare Logic. However, the pre-conditions and post-conditions are what you have to add to the code yourself, otherwise the system won't work.

For example, how does the system know that I want the property "x>0"? I have to write it down myself. Therefore, to use Hoare Logic, you have to add many pre-conditions and post-conditions to the code. These conditions need to be written in a way that requires a deep understanding of the programming language and formal logic principles. This work requires experts who have undergone rigorous training and takes a lot of time.

### Automatic annotations are not possible

Thus, even with Hoare Logic, program verification is not a trivial task. Consequently, some people have taken advantage of this and proposed a similar idea, claiming they will use "deep learning" to learn from existing annotated code and eventually have the machine automatically tag these pre- and post-conditions. They have already written this as an "advantage" in their white papers: "Our method is automatic, while others are manual...."

Unfortunately, "automatic annotation" is the same fantasy as "automatic programming." The challenge with automatic programming is that the machine cannot know what you want to do. Similarly, the challenge with automatic annotation is that the machine cannot know what properties (properties) you want the code to satisfy. These pieces of information only exist in your mind, and if you don't express them, no one else, including machines, can know. only if you write it down, a machine will never know what conditions (preconditions) the function's parameters should satisfy, nor what conditions (postconditions) the function's return value should satisfy. For instance, in the above example, how would the machine know that you want the program to execute with x being greater than zero after the function call? It can only know this if you tell it.

You might ask, can deep learning help out then? Let's think about it.... You can feed deep learning systems with millions of lines of already annotated code. You can tag the entire Windows system, the entire Linux system, Firefox's code, as well as some fighter jets and spaceship code, and input it into the deep learning system for "learning." Now, do you know what I'm about to write next, a new function, and what properties I want it to have? It still doesn't know that! Only I know: it's meant for scooping my cat's poop :p

Therefore, using deep learning to auto-tag Hoare Logic pre and post conditions is similar to trying to practice mind-reading, which is obviously impossible. As seasoned PL and formal verification experts, they should know this is impossible to automatically implement. They propose this idea and present it as an advantage over other smart contract projects, of course, just to lure the uninitiated and collect coins ;)

If deep learning could generate pre and post conditions and thus completely automatically verify a program's correctness, this method should have blown up in the formal verification field long ago. Every formal verification expert wants to be able to completely automatically prove a program's correctness, but they have known for a long time that this is impossible.

Designing languages to tell the machine what we want, what constitutes "correct," is itself the work of PL experts and formal verification experts. We still need excellent programmers to write this code and tell the machine what we want. We also need excellent security experts to add pre and post condition annotations to the code and tell the machine what constitutes "correct and secure code".... All of this must be done manually and cannot be automated by the machine.: I haven't excluded the possibility of manually adding Hoare Logic marks to smart contracts, it has certain value. I just want to remind everyone that these marks must be written manually, they cannot be automatically generated. Tools can provide some assistance, but if the person writing the code is careless, they cannot ensure the program is completely correct.

How to ensure the correctness of smart contracts? It's the same question as ensuring the correctness of a program. Only those who know how to write clean, simple, and rigorous code and think carefully can write correct smart contracts. Regarding how to write clean, simple, and reliable code, you can refer to some of my previous articles.

Doing smart contract validation work might earn you money, but it's extremely tedious and lacks a sense of achievement. I have refused several blockchain cooperation projects for this reason. Although I am interested in other ideas about blockchain (such as decentralized consensus mechanisms), I have no confidence in the correctness validation of smart contracts.

: Smart contracts are a fallacy

In fact, I believe that the concept of smart contracts as a whole is questionable and a relatively large misconception. The systems of Bitcoin and Ethereum should not, and do not need, to have scripting languages in them.: Bitcoins unlocking script execution method has a fundamental error at the outset, leading to an injection security vulnerability. Users can write malicious code, causing the script to system crash. The initial unlocking method of Bitcoin was to concatenate the two scripts (unlock script+lock script) as text and execute them. Handling programs as text is a major taboo in programming languages. Even a slightly experienced hacker knows that this is a likely security hole.

Ethereum's Solidity language has a fundamental error at the outset, leading to the theft of $5 million worth of Ethereum. Ethereum's smart contract system consumes a large amount of computational resources, resulting in severe performance issues.

Despite the fact that the creators of Bitcoin and Ethereum are probably experts in cryptography and distributed systems, I must admit that they are outsiders in the PL field. But if insiders had made these languages, wouldn't it be better? I don't necessarily think so.

The first problem is that the PL field is filled with various sects and evangelists. Generally, PL insiders tend to complicate problems and design a perfect language in their "faith," disregarding the lives of others. If you're unlucky, you'll encounter those geeks full of "pure functions," monads, dependent types, and linear logic... Then the language they design will never be used.

Responsible PL researchers try to avoid creating new languages first. If a problem can be solved without a new language, they don't design a new language, and they avoid using embedded languages in systems as much as possible. So, if I had designed Bitcoin, I wouldn't have designed a language for it at all. Let users programming be dangerous. Few users can write correct and reliable code, and language systems' development processes rarely occur without bugs. Design errors in language systems provide opportunities for hackers to write malicious scripts for destruction. No language or its compiler and runtime system has ever been perfect from the start and required years to stabilize.

Additionally, you need to consider performance issues. For decentralized distributed systems, these issues are even more challenging. This is not a major concern for ordinary language problems; you don't use it to control planes. However, for digital currency systems, almost no room for error is allowed.

Instead of worrying about designing these smart contract languages, it might be better not to have such features at all.

Do we really need those scripting features? Bitcoin has a scripting language, but the common scripts are actually fewer than 5, which can be hardcoded directly. The Ethereum whitepaper made many applications envisioned, but what valuable applications have appeared on the EVM? I don't think we need these smart contracts. Digital currency only needs to do one thing well, to be used securely and efficiently as money.

Dollars, RMB, gold.... Do they have contract functions? No. Why should digital currency be tied to this feature? I think this goes against the principles of modular design: one thing should do one thing only and do it well. Digital currency should be like money, only needing to implement simple transfer and exchange functions. Contracts should be an independent system and not tied to currency.: That contract, what should we do about it? Give it to lawyers and accountants to handle, or use an independent system. Have you ever thought about why the legal systems of the world are not controlled by programs and automatically executed? Why do we need lawyers and judges, not just robots? Why do some courts still require a jury, instead of just following the legal provisions to make judgments? This is not just a historical issue. You need to understand the essential properties of law to grasp this, completely mechanical enforcement without human involvement is not feasible. Smart contracts aim to remove humans from the system entirely, which will lead to problems.

Regarding the excessive functionality, it is actually a form of over-engineering. Spending energy on tweaking the smart contract system might significantly delay the acceptance of digital currencies by the world. Frankly speaking, I've tried various digital currencies and learned about their underlying technologies. These technologies are quite fascinating, but these digital currencies are still in the experimental phase and have a certain distance to go before they can be used as actual currency. Focusing on improving their currency functions will accelerate their acceptance, while investing energy in researching smart contracts seems misguided to me.

In this aspect, I believe Bitcoin does a more straightforward job compared to its successors (like Ethereum). Bitcoin does have a scripting language, but it doesn't overemphasize its role. Bitcoin's scripting language is very simple and not Turing complete. This forces users to write scripts with simple functions that don't harm the system's performance and are easy to verify. Conversely, Ethereum spent too much effort on smart contracts, making it overly complex, Turing complete, and ultimately causing various issues, which affected the acceptance of its most crucial currency functions.