---
layout: post
title: "How to Respect a Programmer"
---


A friend of mine, whom I hadn't seen for a long time, came to the Bay Area of San Francisco. However, when I saw him, he was going through the most painful period of his life. He told me that when he joined the company, they praised his performance during the internship and academic background, saying that he didn't need to interview or graduate with a degree to join the company as a formal employee. But a short year later, this friend felt no respect from the company for his skills. The manager assigned him to do meaningless tasks with no technical substance and criticized him for being too slow. Under the double blows to his self-respect and job security, he often worked overtime on weekends, but still couldn't please the manager.

I understood this friend's abilities, and in any top-tier company, he would have excelled. His name I will keep confidential, but I must reveal the name of the company where he worked - it's the place many aspire to as if it were heaven itself, Google. The experiences he described were reminiscent of my internship experience at Google years ago. I still remember my teammates watching me use Emacs and mockingly telling me, "Press ctrl-k!" I still remember being reprimanded for not being able to write high-quality code that my teammates couldn't produce. I still remember the envy and admiration of the "Google geniuses" among my colleagues. I still remember the collective groan from the team when I was left alone to complete a project that the entire team couldn't even imagine. ...

This friend of mine is indeed a top expert in his field. The disregard for a professional's value, the shallow judgments and treatment of them, is not unique to Google. Several companies I've worked for had similar issues. Sometimes it's not the company management needlessly applying pressure, but rather the destructive infighting among programmers, criticizing and harming each other's self-respect. More recently, Linus Torvalds' public disrespect towards the audience during a speech illustrates this attitude that values only technology and disregards people, which is quite common in the programming community.

Later, I discovered that programmers don't intentionally disrespect others or attack each other, but rather they don't understand what it means to "respect" someone and don't know how to communicate without causing hurt. Respecting others is a "technical problem," not something that can be done with ill intent. With this in mind, I want to outline the origins of disrespectful behavior towards people and provide some suggestions on how to truly respect a programmer. I hope these suggestions will be of use to corporate management and offer some encouragement to the programmers who are enduring similar suffering. To build a company culture where everyone respects each other, I believe the following points should be noted.

### Recognize and acknowledge historical baggage in technical domains

Many disrespectful behaviors have their roots in some people's dogmatic belief that a certain technology is the best in the world, and everyone must know these things to be a qualified programmer.

This phenomenon is particularly prevalent in the Unix (Linux) world. Advocates of Unix systems (I was once one of them) would evangelize everywhere, telling you how stupid the designs of other systems are and that you should follow Unix's "philosophy." They believed Unix was the ultimate operating system, but the truth is, Unix is a poorly designed system. It seems deliberately designed to be difficult and error-prone, yet it is praised as "powerful" and "flexible."

Open-minded programmers know that Unix's designers actually knew very little about design. They were not the best programmers in the world, but they were successful at one thing: they were very good at creating cults and exploiting people's blind loyalty. Unix designers blamed users for not being able to learn or making mistakes, making them feel it was their own fault. I. The Computer Age: Living in the Dark Ages of Software

If you have a certain understanding of computer science, you'll find that we are still living in the Dark Ages of computers. Particularly in software systems, they are built upon a heap of historical legacy, which includes clumsy operating systems (such as Unix, Linux), programming languages (like C++, JavaScript, PHP, Go), databases, editors, version control tools, and so on. These often trouble us, and this is why you need so-called "experience" and "knowledge." However, many IT companies refuse to acknowledge this, as their long-standing attitude has been "everything is the fault of the programmer!" and "as a programmer, you should know this!" This creates a "new emperor's clothes syndrome"â€”everyone dislikes using these poorly designed tools but is afraid of being ridiculed or questioned, so they all pretend to be able to use and learn them, while no one dares to say they are difficult or point out the designer's mistakes.

As for me, I am an exception to this "hacker culture." My diverse education helped me escape from the dogmatic and narrow-minded mentality of those who insist on using these inferior tools, no matter how difficult they are. Whenever someone comes to ask me about a tool or a language because they don't know it, I tease the designer of that tool and tell them, "You have no reason to know about these junks, but the truth is..." Then I explain to them how it works, how to use it, and the design flaws that led to our strange workarounds. I believe that all IT professionals should have this teasing attitude towards these tools. Only then will the software industry make substantial progress, instead of being hindered by these poorly designed tools and suffering from mental blockages.

II. Essential Knowledge vs. Surface Knowledge: Don't Overvalue Experience

In any field, only a small portion of knowledge is essential, while the rest is superficial and shallow, derived from the essential knowledge. Both essential and surface knowledge are useful, but their proportions and importance are not the same. Therefore, it is crucial to distinguish essential knowledge from surface knowledge and not confuse the two, as our attitudes towards them should be different. Since surface knowledge is essentially static and can easily be inferred from essential knowledge, we should not assume that we are superior because we know a lot of surface knowledge, nor should we look down on others because they don't know some surface knowledge.1. In IT companies, there are often people who think they are superior because they are proficient in some seemingly complex command lines or certain difficult programming languages. If they hear you don't know how to use a certain command, they act as if you're like a French person not knowing about Napoleon or an American not knowing about Washington. These people haven't realized that some of their colleagues actually possess essential knowledge, and they have the capability to derive and create all these tools from their existing knowledge, rather than just using them, and even design them to be more refined and user-friendly.

2. If you're this proficient person, beware of interpreting your colleague's humble request as an opportunity to flaunt your "resume." This colleague is not clueless but rather indifferent and has no time for such trivial matters. His confusion often stems from the tool designer's mistakes. He is well aware of this, and he knows his technical skills surpass those of the tool designer. However, for politeness, he often doesn't directly criticize the tool's design but instead humbly blames himself. So your colleague's humble plea for help is genuinely meant to create a friendly and harmonious atmosphere, saving time for more important tasks. This humility does not mean he is worshiping you or acknowledging his technical inferiority to you.

3. The correct approach is to sincerely understand this confusion and honestly admit the irrationalities and shortcomings in the tool design. If you approach it with a humble demeanor rather than an arrogant one, your colleague will happily learn the trivial knowledge they need from you and remember it, preventing future interruptions for trivial matters. However, if you adopt a "the world only knows me for my clever tricks" attitude, your colleague will likely develop a disdainful emotion towards you, along with the tool. He will forget the usage of this thing and will no longer bother you for help, instead dragging it on indefinitely.

4. Don't think you're smarter than everyone else and don't judge others' intelligence and abilities.

In IT companies, there are many people who believe they are smarter than everyone else and are always judging others based on their words, whether they are serious or joking. Whatever you say will be used as a benchmark to assess their intelligence and abilities. occasion, you write some code but know you don't have enough time, yet there are more important things to do. If someone sees this while you submit the code, they will firmly believe you can only produce such code throughout your life. This is called "wishful thinking," people only see what they want to see. Such people are always hoping to be smarter than others, so they are always listening for opportunities to appear dumb in comparison. They only see others' mistakes because that is proof of their superiority.

Of course, who would like such people? Yet they are quite common in IT companies. You dare not speak to them, especially not joke with them, for they will take your jokes as evidence of low intelligence or inexperience. You dare not ask them questions, for they will think you are questioning their intelligence. I have found that such people generally have a subconscious sense of inadequacy in some areas, including intelligence. They are always looking for opportunities to appear superior. I have not thought of an effective way to correct this psychological problem, but as I mentioned earlier, realizing that the entire industry, including your idols, don't know much and are just "making do," is an effective way to relax this mentality.

Sometimes I like to self-deprecate and tell people, "Our industry ancestors made so many bugs for us to fix. Now you made a pile of shit, and I made a pile of shit too. My shit seems to be a little less stinky than yours." This way, not only does it show psychological equality and respect, but it also avoids making the other person feel inferior due to your humility. In truth, this line of work doesn't require a high IQ, so it's best to completely abandon the judgment of others' intelligence. You are not smarter than anyone, and you are not dumber.

Always remember that your colleagues and subordinates are people of equal intelligence to you. They are reasonable people, yet they will not simply follow your low-level commands. My Google teammate's approach is a good counterexample. She just wanted to tell me, "Delete this line of text and change it to this...." It was such a simple task, yet she acted cryptically, not directly expressing her "high-level intent," but instead giving a very low-level instruction: "Press Ctrl-k...." Her tone was as if she was speaking to an unintelligent elementary school student, implying that she knew so much more than they did.: Who among Emacs users doesn't know that Ctrl-k deletes a line of text? Given that you're dealing with an experienced Emacs user now, I believe the issue here is clear. Such low-level commands not only lack logic but also constitute a serious insult to another person's intelligence. What am I, a monkey? If this Googler makes clear her advanced intentions, it will be easy for people to accept her psychologically and logically, for instance, she could say: "This line in the configuration file should be deleted and changed to..."

In project management, it's important to keep this in mind. Before asking someone to do something, explain why it needs to be done and its importance. This way, people can understand and respect the intelligence of programmers.

### Don't expect newbies to learn from you

Many IT companies like to treat new hires like beginners, expecting them to "start from scratch" and "learn from" themselves. For example, Google calls new employees "Nooglers" (Newbie Googlers), even giving them a special spiral hat, implying that they should be humble and learn from the great Google, only to fly high in the future.

This is a wrong approach because it completely disregards the background knowledge that new hires already possess and imposes your position upon them. Just because you say "start from scratch" doesn't mean you can erase someone's past. New hires may not be familiar with your code structure and engineering methods, but that doesn't mean your methods are superior. Is there really much to learn from Google? Is college education worthless? In fact, it's the opposite. I can openly admit that I learned the most essential knowledge from my professors, while what I learned from Google was mostly shallow skills that could be memorized by rote, and many of them were actually mediocre. All the innovative achievements I made at Google were derived from the essential knowledge I gained from college. Many PhD students look down on Google because Google is not only technologically mediocre but also arrogant, expecting others to "learn from" them, packaging themselves as the most advanced, surpassing other companies and schools, and even flaunting it. A company that truly respects talent will understand and utilize the unique skills brought in from the outside, rather than merely expecting them to conform to the company's ways. Only then can we keep our sharp weapons competitive in intense competition. If you insist on making new people "learn" while ignoring their unique strengths, you will eventually become mediocre.

Don't act like a teacher, distinguish "learning" and "understanding"

As mentioned in the text, much of the so-called "knowledge" in the IT industry is just some clever tricks used to bypass the mistakes in previous designs. So when you encounter someone who doesn't know something, don't assume that you've "taught" them something or that you've become their teacher. Acting like a teacher, using language like "follow me," is actually disrespectful to people.

People love to use the word "learning" when they obtain information, but I believe this word is overused. We should distinguish between two situations: "learning" and "understanding." The former refers to knowledge gained through someone else's guidance and your own understanding, which cannot be easily manufactured. The latter simply means that you have "understood" something you previously did not know. For example, if someone puts an object in a place you don't know, you ask them, and they tell you. This type of information acquisition is not called "learning," and this information is not called "knowledge."

However, in the IT industry, much of the so-called "learning" is similar to this situation. For instance, someone writes some code or designs some framework modules. Someone else doesn't know how to use it, so someone else explains it to them. Many people call this "learning," but this is disrespectful to people. This code and design, I could also do it, perhaps even better. Why should I say I'm learning from you when I've just understood it? I. To learn, one must acquire more advanced knowledge and skills, and have a sense of "gain" and "improvement." Simple information acquisition cannot be called "learning," it can only be called "understanding."

II. Clarify your own requirements, avoid using accusatory language.

Some people are quite peculiar. They never explicitly told you what they want or have specific requirements, but in their subconscious they believe they have already communicated this to you. Later, they find that your methods do not meet their requirements, so they severely criticize you for not following their "mental image" of how things should be done. This phenomenon is not limited to programmers, but also includes ordinary people in daily life. For instance, my mom is a typical example of such a person, and I used to have a very difficult time living with her. She has a certain "correct" way of doing things in her mind, and if you don't guess it, you will be scolded. To avoid being scolded, you might as well not do anything, and then she would say you're lazy. So, you're left in a quandary.

There are quite a few such people in IT companies. They assume that certain information has already been conveyed to you, but in reality, they haven't communicated it at all. Later, they start criticizing you for not following their requirements. Some extremely strange companies have programmers who not only like to act like teachers but also primarily "teach" you "knowledge" by criticizing. They don't tell you any rules beforehand and only criticize you when you violate them. I once worked for such a company, and I won't mention its name.

Now, let me give you a concrete scenario as an example:

In a software development team, a team leader assumes that the team members already know the project requirements and deadlines. However, he never communicates this information explicitly. Instead, he only criticizes team members when they miss deadlines or deliver subpar work. The team members, not knowing the requirements, are left in the dark and may deliver work that doesn't meet the team leader's expectations. This can lead to misunderstandings, frustration, and ultimately, a less effective team. To avoid these issues, it's crucial for team leaders to clearly communicate project requirements and deadlines to their team members.: Did you push to master? B: Yes? Why? A: You're not supposed to push to master! Only pull requests are allowed! B: But you didn't tell me that before... A: You know now?!

Notice that this is not a technical issue, but an etiquette issue. You didn't inform others of certain rules beforehand, so you shouldn't use accusatory language when speaking to people, and your rules may not always be correct. Therefore, I remind all IT companies to make any technical requirements clear beforehand to ensure that programmers are aware and understand. If not, don't blame others for not following the rules, as this is a very damaging way to treat people's self-esteem. In fact, you should never use accusatory language, as it has no positive effect on problem-solving and worsens interpersonal relationships, eventually leading to more serious consequences.

### Programmers' workload cannot be measured by time

Many IT companies' management layers do not know how to estimate programmers' workload, so they use the time they spend sitting at their desks as a measure. If you have strong abilities and solve the most difficult problems quickly, they won't let you idle, but will give you other low-level tasks instead. This is an unfair practice. For example, a high-ability employee is like an F1 racecar, with horsepower and speed far exceeding others. On the other hand, ordinary people take a long time to solve or even cannot solve problems, and these problems are quickly resolved by the high-ability employee. This is like an F1 racecar that completes a long route in a blink of an eye. If you measure workload by time, the racecar completes the entire route in a very short time, so the workload you calculate is much less than that of an ordinary car. Can you then say that the racecar is not working hard enough and should work faster? This is clearly incorrect.

Physical laws state that energy = power x time. Workload should also be calculated using the same method. Intelligent companies, those that truly understand programmers, will not expect high-level programmers to work non-stop. High-level programmers, due to their ability to find alternative solutions, can handle problems that are much more difficult and require more brainpower than ordinary programmers. They need better rest, maintenance, and entertainment, among other things. If you overwork high-level programmers, not stopping for a moment, and they finish interesting and challenging tasks, they will eventually slow down their pace, sometimes even claiming they haven't finished when they have. Instead of this, why not just expect them to work for a shorter period and complete the tasks? This does not mean that beginner programmers should work excessively. Programming is a grueling mental activity, and overtime work along with pressure will only lead to decreased efficiency and lowered quality.

Don't let others fix your bugs.

I have already discussed this in a separate article. Having one programmer fix another programmer's bugs is not only inefficient but also disrespectful to the programmer's personal value. Over time, it will lower the programming enthusiasm of the engineer, potentially leading to losing valuable employees. Code is a work of art created by people, and its quality reflects the personality and dignity of the person who wrote it. If person A wrote the code and doesn't want to fix the bugs in it, it means that A considers their own code as garbage and beyond repair. If person B is asked to fix the bugs in A's code, it is like asking B to clean up someone else's trash. Needless to say, B's position in the company and the respect they receive would be questionable. Secondly, having one person fix another person's bugs is extremely inefficient. Every person has their own coding style and techniques, and the code contains the thought process of the individual. It is difficult for people to understand each other's thoughts without explanation, regardless of their programming skill levels. If you cannot understand someone's code, you cannot evaluate their programming abilities. Therefore, having one person fix another person's bugs will inevitably lead to low efficiency. In fact, the more skilled the person, the lower the efficiency, as they cannot fathom how such poor code was written. They would rather rewrite the entire code than try to understand and fix the bugs.

When I was a teaching assistant in college for programming courses, I found that if students' code had issues, you couldn't easily help them fix them. Despite my superior skill level, I often couldn't understand their code, let alone modify it to fix the bugs. As mentioned earlier, some people don't even know what they're writing. Looking at such code is as appealing as eating feces. For such code, all you can do is tell them it's incorrect. As for why it's incorrect, you can only suggest they change it themselves or recommend they rewrite it. You might be able to provide general directions and ideas, but delving into the specifics is impossible and not your responsibility. My professor advised me to do this: if the code cannot run, simply cross it out, without explanation or justification, and wait for them to fix their program or come to office hours to explain their thought process.

If you understand what I'm saying, from now on, take responsibility for your own code and stop letting others fix your bugs or fixing theirs. However, if someone leaves the company, someone must fix the bugs they leave behind. In such cases, you should be very careful with what you say. You must clearly state the special reasons why their help is needed, emphasize that it's not their fault, and that it wasn't their responsibility to begin with, but due to circumstances, they are the only option. Only then will programmers willingly help fix another person's bugs in such critical situations.

As for those who insist on others writing tests, in many programmers' minds, "process" and "testing" are more important than the actual problem-solving code. They may speak eloquently about these things, but in reality, they might not know much more than following the rules. These people, who lack the ability to effectively solve complex problems with simple and elegant code, love to scrutinize every rule when others submit their code for review. They call out, "Testing is important! Coverage is important! You need to add more tests to pass my review!" I originally intended code review to help find potential issues, but some people seem to treat it as an opportunity to judge others' abilities, experience, and even intelligence. They don't understand the true value of other people's code and only judge based on surface appearances. I submitted high-quality and difficult code at Google, but some people who couldn't write such code themselves didn't even express basic confirmation, instead grumbling: "Write- test- try!" Would I be happy about that?

I don't deny the importance of testing, but when people bring up these issues with disrespectful tone and attitude, it's off-putting. These people didn't contribute anything substantial to solving the problem, and when someone submitted a solution, they didn't express respect and confirmation for the person who truly contributed, instead blaming the other person for not writing tests. It's as if they, who were less skilled, solved the problem and had the power to judge the code quality: "I don't care how good your code is, I can't write it, but you not writing tests makes you unprofessional. Do you understand the importance of testing as a programmer!"

Communication issues often lie not in what you say, but in how you say it. So my point is not that you shouldn't suggest writing tests, but the suggestion should be made with a respectful tone. Since you haven't done the actual work, polite language, such as "please" and "can we"..., is necessary. People often speak without considering tone and attitude, making others feel off-put, but use being an engineer as an excuse for their lack of people skills. Always remember, you haven't done the work, so your speech should be tactful, and avoid imperative commands that make it seem like the other person has no choice, like they're breaking the rules.

Polite language has nothing to do with one's profession. As an engineer, you cannot use lack of politeness as an excuse for your speech.

### About Git etiquette

Regarding Git etiquette, it's important to remember that the primary goal is to facilitate collaboration and maintain a clean, organized repository. Here are some guidelines for good Git etiquette:

1. **Commit messages**: Write clear and concise commit messages that accurately describe the changes you made. This helps others understand the context of your changes and makes it easier for them to follow the project's development.
2. **Branching**: Create a new branch for each feature or bug fix you're working on. This allows you to work independently without affecting the main branch and makes it easier to merge your changes back into the main branch when you're done.
3. **Pull requests**: Use pull requests to propose changes to the main branch. This allows others to review your changes, provide feedback, and ensure that your changes don't conflict with ongoing work.
4. **Merging**: Merge changes from other branches into your local repository regularly. This keeps your local repository up-to-date with the latest changes and reduces the risk of merge conflicts when you're ready to merge your changes back into the main branch.
5. **Rebasing**: Use rebase instead of merge when possible. Rebasing keeps the commit history clean and linear, making it easier to follow the development of the project.
6. **Conflicts**: Resolve any merge conflicts promptly and communicate with other team members if necessary. This ensures that everyone is working with the same codebase and reduces the risk of further conflicts.
7. **Deleting branches**: Delete branches that are no longer needed. This keeps the repository clean and organized and reduces the risk of accidental merges or conflicts.

By following these guidelines, you can help maintain a clean, organized Git repository and facilitate effective collaboration among team members. I. Git is currently the most popular coding version control tool. In layman's terms, Git is like a "repository" or "depot" for code, allowing multiple people to modify the code and know who changed what parts. However, regardless of the tool - be it an editor, programming language, or version control system - these are secondary things compared to a programmer's core ideas, serving only as supportive functions. Yet, Git seems particularly frustrating.

II. Git is not as user-friendly as some boast, and it has noticeable design flaws. Following the Unix tradition, Git lacks a good wrapper, exposing its internal implementation details to users, forcing them to ponder the designer's intentions instead of knowing what to do. Users are forced to remember a multitude of odd commands, and the command line design is not very rational. Sometimes you need to add -f-type parameters, and their positions may not be consistent, and adding them does not always yield the expected results. Various quirks, such as "detached head," force users to understand the inner workings. With each Git update, new features and commands keep emerging, and eventually, you'll find the command line resembling a (low-quality) programming language. If you're familiar with ydiff's design philosophy, you'll realize that Git-type version control tools are essentially relics. Yet, many revere Git as if it were sacred because it was designed by Linus Torvalds.

III. The most annoying aspect of Git is not its complexity, but the condescending attitude of its "experienced users" towards you. Some people, proud of their Git proficiency, adopt a superior tone. As more users join, Git's initial design becomes increasingly inadequate, leading to an increasing number of established conventions, which could be compiled into a book! Following the Unix tradition, Git offers you many ways to entrap yourself, and when issues arise, it's your fault for not knowing. So, you often hear people complaining: "You're not supposed to do it that way! Unix philosophy doesn't prevent stupid people from doing stupid things...." If you submit code without knowing Git's established conventions, you'll be scolded: "You rebased and committed!" "Don't push to master!" "Don't merge!" "Squash commits!" If you don't use git submodule and other features, you might be looked down upon: "You should know this!"

IV. To illustrate, the scolding tone given off by these people is akin to a gym manager shouting at an Olympic medalist who returns their training equipment: "This goes here! That goes there! Do you understand the rules?" Have you understood the issue now? A company that respects programmers should treat them as athletes, placing their code on a pedestal. Other tools should be treated like equipment storage. We respect equipment managers, but if athletes don't understand your equipment placement rules, they should be shown respect and understanding, not scolded. Therefore, regarding Git's commands and usage, I recommend introducing them to newcomers as follows: "You shouldn't need to know this, but since we don't have better tools, we'll have to make do...." I. Introduction

This document outlines the procedures for issuing and managing certificates of deposit (CDs) in our bank. The objective is to ensure that all CD transactions are conducted in a fair, efficient, and secure manner, in compliance with relevant laws and regulations.

II. Eligibility

1. Individuals: Any customer who meets the following requirements is eligible to open a CD account:
   a. Must be at least 18 years old.
   b. Must have a valid identification document.
   c. Must have a minimum opening balance as specified in the CD terms and conditions.

2. Legal Entities: Any legal entity that meets the following requirements is eligible to open a CD account:
   a. Must be duly registered and authorized to conduct business in accordance with applicable laws and regulations.
   b. Must provide proof of existence and authorization to open the CD account.
   c. Must have a minimum opening balance as specified in the CD terms and conditions.

III. CD Terms and Conditions

1. Minimum Opening Balance: The minimum opening balance for a CD varies depending on the term and interest rate.
2. Term: The term of a CD ranges from 7 days to 5 years.
3. Interest Rates: Interest rates for CDs are fixed for the term of the deposit.
4. Early Withdrawal Penalties: Early withdrawal of a CD before maturity may result in penalties.
5. Renewal: Upon maturity, a CD can be renewed or withdrawn.

IV. Opening a CD Account

1. Application: Customers can apply for a CD account by completing the CD application form and submitting it to the bank.
2. Funding: Customers must fund the CD account with the minimum opening balance at the time of account opening.
3. Confirmation: The bank will confirm the CD account details and provide a confirmation statement to the customer.

V. Managing a CD Account

1. Interest Payments: Interest payments are made annually or at maturity, depending on the CD terms and conditions.
2. Renewal: Upon maturity, customers can choose to renew the CD or withdraw the funds.
3. Early Withdrawal: Customers may request to withdraw their funds before maturity, subject to penalties.
4. Transfer: Customers may transfer their CD funds to another account in the same currency and with the same term, subject to bank policies.

VI. Security

1. Confidentiality: The bank will maintain the confidentiality of customers' CD account information.
2. Fraud Prevention: The bank employs various fraud prevention measures to protect customers' CD accounts.
3. Dispute Resolution: In the event of a dispute, customers can contact the bank's customer service department for assistance.

VII. Conclusion

This document outlines the procedures for issuing and managing CDs in our bank. By following these procedures, we aim to provide our customers with a fair, efficient, and secure CD experience.