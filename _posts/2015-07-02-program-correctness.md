---
layout: post
title: "speaking of a program's correctness"
---


In academic circles and in industry, there are many people overly concerned about so-called "program correctness," some even to the point of being overly cautious, sacrificing the essential for the peripheral. Here are some examples:

- Many people place too much importance on testing (test). They want to strictly test the code before it's even been written a few lines, preventing potential future mistakes. These people often find themselves bogged down by testing, with bugs in the code as well as in the tests.

- Some people are overly concerned with "which language to use." They believe that they can only complete basic tasks using the latest, coolest, most feature-rich language. These people keep chasing after the latest languages as a "magic potion," only to be disappointed time and again, and they end up not writing any useful code.

- Some people overly value "type safety" (type safety), often complaining that the language in their hands lacks some flashy type system features, and even going so far as to say they can't write code anymore! They fail to see that even without some type safety ensured by the compiler, the code may not have any problems at all, and might even be simpler. Some people go to extremes, believing that all code must be written using so-called "formal methods" and proven correct using machine theorem proofs to ensure it is 100% error-free. These people are thrilled with proving toy-sized code all their lives, but they never write code that solves real-world problems.

100% reliable code, what a perfect ideal! But in the end, you find that the people who are always harping on about "correctness" and "reliability" are usually the ones with their eyes too high and their hands too low. They haven't written any code that solves practical problems, but they're more than happy to criticize others' "code quality." Their own code is often overly complex, and they love using seemingly deep and esoteric techniques to ensure "correctness." Their code is tied up by so-called "testing tools" and "type systems," yet it's still riddled with bugs. In the end, their obsession with "correctness" turns out to be just an excuse for not solving the problems at hand.

### Measuring the Standard of a Program

These people don't understand a fundamental truth: you have to write the program first before you can talk about its correctness. The most important standard for evaluating a program is whether it effectively solves the problem, not whether it is correct. If your program doesn't solve the problem, or solves the wrong problem, or even solves the problem but is difficult to use, then no matter how correct or reliable it is, it's not a good program.

Correctness is not simplicity, not elegance, not efficiency. A complex, inelegant, inefficient program, no matter how correct you prove it to be, still won't work well. It's like having a house before you can demand that it be safe. Would a homeless person, passing by an empty house, refuse to live in it because it's "not 100% safe"? Writing code is like having a house, and the correctness of the code is like the safety of the house. Writing code that solves problems is always the first priority. And the correctness of the code, no matter how important, is always the second priority. The emphasis on the correctness of the code should never overshadow the writing of the code itself.anytime we discuss this issue, I like to use an analogy: if "Lemma Conjecture" was proven by Wang Huanwu, would it be called "Wang Huanwu Theorem" instead? Of course not. It would still be called "Lemma Conjecture"! This is because, no matter how smart or powerful a person is, even if he can prove the Lemma Conjecture, it was not his first discovery. If Lemma hadn't proposed this conjecture, you wouldn't even think of it, let alone prove it. So I like to say, a first-rate mathematician proposes conjectures, a second-rate mathematician proves others' conjectures. The same logic applies to the person who writes code to solve problems and those who go to test or prove his code correctness. Because if he didn't write that code, you wouldn't even know what to test or prove!

As for improving a program's correctness, it may not be as important as solving problems, but it is still indispensable. However, this does not mean that we should constantly advocate for "testing" and "formal proof" to increase a program's correctness.

If you delve into the logical deduction of a program, you will know that the abilities of testing and formal proof are quite limited. Testing can only test common cases, but cannot cover all cases. Don't be fooled by so-called "test coverage". A line of code being tested and not having errors does not mean there will be no errors in that location. Whether a line of code has errors depends on the conditions preceding its execution. The number of these conditions is in a combinatorial explosion relationship, and there are virtually no tests that can cover all these prerequisite conditions.

Formal methods are effective for very simple and direct programs, but as soon as the program becomes a little more complex, formal methods become difficult to apply. You might not have realized it, but you can write a very small amount of code to implement Collatz Conjecture, a mathematical conjecture that has not been proven yet. The code used in practice is likely to be much more complex than this mathematical conjecture. If you try to use formal methods to prove all the code, you are basically giving up on completing the project.: What is the most effective way to improve a program's correctness? In my opinion, the most effective method is none other than repeatedly pondering and reasoning about the code, making it simple and clear until you can instantly tell with a single glance that it cannot have any issues.