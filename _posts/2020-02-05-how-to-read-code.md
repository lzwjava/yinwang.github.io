---
layout: post
title: "How to read other people's code"
---


Many people have asked me "how to read existing code" with the hope that I have a good method. Some people want to improve their own code quality by reading "excellent projects" like Linux kernel. For this question, I usually don't have a good answer because I rarely improve myself by reading other people's code. I have high standards for the code I read, as there are too many poorly written codes in the world, reading them will harm my thinking. The same logic applies to articles.

However, this does not mean I cannot communicate and collaborate with other programmers. I have other ways. Instead of reading code, I prefer others to explain their code to me using simple language or diagrams to explain their thoughts. With the thoughts, I naturally know how to turn them into code, and it will be elegant code. I don't read many people's codes, but if they explain it to me, I am open to it.

If a colleague asks me to help improve their code, I won't grab the code and bury myself in it, as looking at the code often results in wasted effort or even no benefit. I will make them explain the meaning of the code on the whiteboard first. My colleagues have found that explaining it to me takes a lot of effort. This is because of my high requirements. If there is anything unclear, I will make them explain it again. I will also make them redraw the diagrams repeatedly until I can understand it at a glance. If the diagrams are 3D, I will make them simplify them into 2D, understand it, and then expand it to 3D. I cannot understand complex, high-dimensional concepts, so they must make it simple for me.

Therefore, explaining code to me may take a lot of time, but it is worth it. Once I understand, I can often find the points that others cannot clearly see. Explaining things to me also helps them improve their thinking and language skills, simplifying their thoughts. Many times, I don't even look at the code, and they simplify it themselves after explaining it to me. This saves me mental and visual effort, and they also receive improvement. I recently looked at someone else's code at Intel, where we modified PyTorch. It was not a pleasant experience as PyTorch, despite being widely regarded as useful, has confusing internal code. PyTorch is not Intel's own, so no one could explain it to me. Modifying PyTorch code to add new features proved difficult as I couldn't understand where to make changes from the code itself.

I later found out the reason was that PyTorch's compilation architecture generated a lot of code automatically, making it hard to understand the origin of some code. They had several proprietary file formats with special text determining how code is generated during compilation. These files were read by some Python scripts and output strange C++, CUDA, or Python code. These scripts were actually a Domain Specific Language (DSL), which I had explained the problems of in previous articles. To add functionality to PyTorch, you had to understand how these scripts processed the DSL and generated code. However, these scripts were also disorganized and haphazardly written, resulting in more headaches.

Eventually, I found that relying solely on the code itself to understand it was impossible. So how do we solve this problem? Fortunately, there was an internal engineer at PyTorch who wrote a blog explaining how PyTorch organized its code. The blog's author, E. Z. Yang, I had met at an academic PL conference. He was quite bright, having studied at MIT. However, reading the blog only gave me a basic understanding of what it did and approximately which files to look at, but these files could change daily.

The blog also mentioned that certain directories contained legacy code, and if you didn't know what it was, you should avoid it. Looking at those directories, I saw templates for generating code using C macros, but their usage differed from regular usage. In my opinion, the distinction between "macros" (macros) and "metaprogramming" (metaprogramming) was a significant misunderstanding, and PyTorch's use of macros was even more peculiar and self-righteous.

Do you think reading this blog will help you understand PyTorch code? No, there are still daily encounters with obstacles. Most of the experience comes from experimentation and running into walls. Multiple people working on these tasks and sharing their experiences lead to discussions like, "I found I needed to add this in this file and that in that file, and it seemed to work." At the next meeting, someone else would say, "It's not like you said, and you also need to change this and that, but that's not crucial." Many were aware of the results but not the reasons, feeling like blind men touching an elephant, as the reasons had been hidden beneath a mountain of confusing DSL. I learned nothing from PyTorch's code. I only saw various software development mistakes being repeated. If they had taken my advice earlier, they wouldn't have organized their code this way, they wouldn't have had so many preprocessing, code generation, and DSL. Deep learning frameworks like PyTorch are essentially interpreters for some simple programming languages, the only difference being that the functions written in these languages can be automatically differentiated.

Once upon a time, I wrote a "deep learning framework" with less than a hundred lines of Scheme code. It was actually a small programming language. Although it had no performance to speak of, no GPU acceleration, and incomplete features, it captured the essence of PyTorch and other large frameworks - the functions written in this language could be automatically differentiated. This insight is the most crucial thing. As long as you grasp the essence, the details can be worked out as needed. Repeatedly refining a few dozen lines of code often helps you understand the secrets hidden in projects with hundreds of thousands of lines.

Many people think that looking at large projects can help them improve, but large projects are just an extension of a few dozen lines of core code, with many parts being low-level repetition. Repeating dozens of lines of mundane or obscure code a thousand times turns it into tens of thousands of lines. You won't gain anything by looking at these low-level repetitive parts. The programming ability and insight that shaped my today came not from hundreds of thousands of lines of large projects, but from short, single-digit to dozens of lines of exercises. Don't underestimate these small codes; they are the most essential part of programming. Repeatedly refine and distill the structure within these small codes, and sharpen your thinking. Gradually, your understanding will surpass those headache-inducing projects with hundreds of millions of lines.

So how do I read other people's code? Don't. If possible, I let the code author explain it to me instead of reading it. If the author refuses, and I really need to use their code, I'll mess around with it. And how do I mess around with other people's code? I have another method.