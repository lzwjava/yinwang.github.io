---
layout: post
title: "About Linux, Windows and Mac"
---


I have received many messages recently. They found an old article of mine promoting Linux and wanted to know how to "abandon Windows and learn Linux." I don't know where they found such an old article, it's quite a miracle... I feel a responsibility to clear up any misinformation from my old articles about Linux and clean up my reputation as a "Linux fanatic." I have written some clarifying articles before, but still, people keep asking about Linux. Maybe it's due to the "public opinion pressure," I deleted all the articles.

In short, I want to tell those who think they can never learn Linux:

1. Linux and Unix contain some really bad designs. Don't let Unix orthodoxy scare you. Not knowing some things isn't always your fault, but rather Linux's or the "Unix philosophy"'s. Don't waste time learning the usage of too many tools or delving into the strange command lines. Be careful in analyzing the seemingly difficult, complex things.

2. Windows avoids many problems of Unix, Linux, and Mac OS X. Microsoft is a company worthy of respect, a company that truly cares about programming development tools. I take back my previous disdainful attitude towards Microsoft. Beginners, please learn from the good things in Windows design. Additionally, Visual Studio is a great tool that brings significant programming efficiency improvements. Please don't discriminate against IDEs. Recognize the limitations of Emacs, VIM, etc., text editors. Of course, these positive evaluations do not mean you should work for Microsoft. Just like I like the iPhone, but I don't necessarily want to work for Apple. 1. The best way to learn operating systems is to master (authentic) programming design concepts, rather than learning various strange tools. All operating systems, databases, Internet, up to WEB design concepts and flaws, can be explained simply using programming language concepts.

Let me share my views on Linux and related tools like TeX first. I use Linux every day at work, but I don't want to use it at home. At work, I mainly focus on improving it to make it less troublesome for me. Unix has numerous design errors, which have been regarded as dogma and passed on to generation after generation of programmers, creating a vicious cycle. The Unix shell, commands, configuration methods, and graphical interfaces are all quite poor. Each new version of Ubuntu brings new graphical interface design errors, making it feel like history is reversing. In reality, this is just the surface. The graphical interface used by Linux (X Window) is almost irredeemable at its core. I won't go into detail about Unix's drawbacks here; there's a book from its era called "The Unix Hater's Handbook," which has a chapter called "The X-Windows Disaster." It analyzes and concludes that X Window's supposedly clever client-server design is not as good as it seems.

This book collects the criticisms of Unix from its era. It's interesting that the author of this criticism, Dennis Ritchie, one of Unix's creators, wrote a "counter-manifesto." I used to think that those who criticized Unix were just novices. They must have low IQs or had been brainwashed by Windows and couldn't understand Unix's clever design. However, after learning programming language design principles, I realized that much of what they said was true! Some of them were top programming elites who had written their own operating systems and compilers, with foundations equal to Unix's creators. In the past, they had already used more rational systems like Multics, Lisp Machines, etc.

Unfortunately, in current operating system books, Multics is often used to highlight Unix's "simplicity" and greatness. Unix's books like to tell this story in the first chapter: "Multics failed because of its overly complex design, trying to cover all aspects, and it was expensive." But did Multics fail? Multics, Oberon, IBM System/38, Lisp Machines, ... had many things that Linux still doesn't have today. Unix took what it wanted from Multics, such as virtual memory, file systems, ... Unix's machine was still running until 2000. Unix not only distorted history textbooks but also seemed unwilling to learn from past mistakes, still failing to implement the advanced features that early systems had already implemented. Unix's design has almost no consistency or principles. Various tool programs have redundant and conflicting functions, making it impossible to effectively exchange data. However, Unix ultimately won the battle against more advanced systems in design through its "cheapness," "religion," and "philosophy."

If you want to know which of these "failed" operating systems have advanced technologies that we don't have yet, you can refer to this article: Oberon - The Overlooked Jewel. It introduces Niklaus Wirth's (the designer of Pascal) Oberon operating system.: The victor is the king, but Unix is actually a tyrant. It doesn't allow you to criticize its errors. It uses the public opinion pressure of other programmers to make every system design flaw of its own, being labeled as the user's mistake. You dare not say that a tool's design is flawed, for if others hear it, they will think you are not intelligent, calling you "stupid monkey with a dull knife." This is like the people in "The Emperor's New Clothes," who all knew the emperor wasn't wearing any clothes but still said, "This cloth is beautiful." In short, the concept of "user-friendly" in the Unix world is disparaged and distorted. Unix fanatics are numerous and have a strange "elitist" mentality. They glorify difficult tools and look down on those who use "user-friendly" tools.

I once strongly advocated for FVWM and TeX tools, but now that I look back, their user interfaces were actually terrible design, following in the footsteps of Unix. They mercilessly exposed the unnecessary details and design mistakes of the programmer to the user. The user felt that there were so many things to remember, as if they would never be able to master it. To be honest, after reading TeXbook twice and completing all the exercises (including the most difficult "double bend" exercises), I had almost completely forgotten it a few months later. Why is that? Because TeX's language is poorly designed, it doesn't follow the basic principles of programming language design.

There is a little-known anecdote about TeX. TeX has an "extension language" because of Guy Steele's suggestion. That summer, Steele interned at Stanford and heard that Knuth was designing a typesetting system. He strongly recommended that he use an extension language. Unfortunately, Steele left a few months later before he could help Knuth complete the language design. Knuth, being the "elitist" that he was, always designed difficult things and wrote incomprehensible books?

A good tool should only have a few rules to remember, like chess. But these tools derived from Unix are like "demon chess" or "Three Kingdoms," with too many, boring, man-made rules. Some people look down on graphical interfaces, IDEs, and languages with garbage collection (such as Java), and look down on everything "easy." They don't realize that immersing themselves in someone else's complex rules is forever unable to make them masters. Just like a person, they have the ability to learn various "demon chess" rules but can never reach the level of a chess master. Therefore, easy things are not necessarily bad, and difficult things are not necessarily good. Learning computers (or any other tool) should "choose the right, not the difficult." Memorizing a heap of commands and messy tool usage eventually leaves nothing in your mind. Learning "principled" things is what is timeless.

The technical details of Windows design may have been just as terrible in the early days. But it developed towards more structured and simpler directions. Windows technology evolved from OLE, COM, to .NET, and added Visual Studio, an efficient programming tool, bringing significant productivity improvements for programmers and users, avoiding many unnecessary problems with Unix and C language. Windows programs have been able to exchange data relatively easily since very early on. For example, OLE lets you embed an Excel spreadsheet in a Word document. It's worth noting that these are excellent ideas, beyond the "Unix philosophy." Conversely, due to the influence of "Unix philosophy," Unix programs have exchanged data using strings since ancient times, and the format was not unified, resulting in many programs not being able to copy and paste correctly. Windows' "configuration," all recorded in a central database (registry), greatly simplifies program configuration. Although the registry caused trouble in the Win95 era, it is basically problem-free now. In contrast, Unix's configuration is all recorded in various strange configuration files scattered throughout the system. You don't know which configuration file records the information you want. Each configuration file even has different syntax! This is why Unix companies always need a "system administrator," as software engineers are too lazy to remember these nuisances. I'll compare Windows and Mac again. I know a senior designer at Adobe. He told me that it took them two years to port Photoshop to Intel architecture Mac. All they did was change the processor, yet it took two years to port an application. Why? Because Xcode was far behind Visual Studio. Mac OS X's design reasons made their porting process painful. However, he was proud to say that many people waited two years to buy an Intel architecture Mac just for Photoshop. In the end, he openly admitted that Microsoft was the real company that cared about developer tools. Compared to Apple, Apple may seem user-friendly, but its interface for developers is lacking. Apple was still far from being a complete redesign from Unix. I have a Macbook Air, an iPhone 5, and a retired T60 with Windows 7. I must admit that I love the hardware of Macbook and iPhone, but I find that Windows has more reasonable designs in software.

Why did I used to look down on Microsoft? It was just because I was following the crowd! They said Linux would save us and give us freedom. They said Microsoft was an evil company.... To this day, there are still people around me who irrationally despise Microsoft without knowing the reason. But who made Unix? It was AT&T. Who is more evil, Microsoft or AT&T? I don't know. But you should learn about Unix's history. AT&T discovered that Unix was profitable and sued many people for years. They call Microsoft a monopolist, but AT&T had already established a monopoly and was later broken up into several companies. Which company in the world designs and produces its entire suite from the programming language, compiler, IDE, operating system, database, office software, game console, and smartphone.... I must admit that Microsoft is a company worth respecting.

Companies are all the same, they all act in their own interests. As programmers, let's not be used by them as pawns in their power struggles. Use what's good and learn what's new. What you learn is not owned by those monopolistic companies. We all have free minds.

I'm not here to attack Linux and Mac and promote Windows. The bickering between these systems is mostly irrelevant to me. I just want to tell newcomers to remove the religious, biased, hateful, and disdainful thoughts from their minds. Every time you hate something, you lose the opportunity to learn from it. Postscript: "User-friendly" is a worthwhile topic for study, yet one that is not studied enough. Many UI designers make things look beautiful but they are not convenient or intuitive. If you're interested in what I mean by "user-friendly" design, you can refer to this blog post "What is 'User-friendly'?"