---
layout: post
title: "Decrypting "Design Patterns""
---


Some people ask me, you say the best way to learn operating systems is to learn programming. So, should we also learn some "design patterns" (design patterns)? This is a question I've had an opinion on for a long time, and one that has been tested in practice. I'd like to summarize my thoughts on this here.

In general, there are indeed "patterns" that can be discerned in programs. You can always borrow from past experience to construct new programs. You can call this kind of experience "patterns." However, since the publication of the book "Design Patterns" (commonly known as GoF or "Gang of Four" or "Four Gentlemen") in 1994, the term "design patterns" has taken on a new, distorted meaning. It has become a dogma, leading to the serious complexity and inefficiency of corporate software.

GoF borrowed from the approach of a architect named Christopher Alexander. Alexander gave names to some "design patterns" in architectural studies, trying to give architects a "common language." Unfortunately, Alexander later admitted that his experiment failed. These fixed patterns were unable to effectively convey essential knowledge and did not help novice architects grow into excellent ones.

Copying patterns piecemeal without grasping the essence of things, without "inspiration," is actually unable to design good things. It's like copying "templates" to write a better essay, but not becoming a writer. I am a recluse with limited knowledge, when I heard about this book, I had already learned functional programming and was pursuing a PhD at Cornell in programming language design. One day out of curiosity as to why this book was so famous, I borrowed a copy from the library to read. I soon discovered that the author had merely given new names to the existing programming methods. I drew a mapping between the 20 or so design patterns of GoF and my common programming concepts, and to my surprise, it turned out to be a "many-to-one" mapping. That is, multiple GoF design patterns corresponded to the same concept I used daily. Some concepts were so insignificant that I didn't even need a name for them, let alone multiple names!

Few patterns are worth mentioning, such as visitor and interpreter. Unfortunately, only a few people understand how to use them properly. Visitor, in essence, is a recursive function with pattern matching in functional programming languages. In functional programming languages, this is a simple matter. However, due to Java's lack of pattern matching, many who require similar functionality are forced to use visitor pattern. To maintain "generality," they often turn it into multiple layers of inheritance relationships, making it difficult to determine which visitor is actually doing the work.

Functional language researchers have long known the origin of visitor pattern. If you want to know how to invent Java's visitor pattern from scratch, step by step, you can refer to "A Little Java, A Few Patterns" (published in 1997).

As for interpreter (interpreter) pattern, after looking at the examples in the authors' programs, I found that they didn't actually write interpreters, or they didn't know how to write elegant and correct ones. If you want to write a good interpreter, you can refer to my blog post "How to Write a Good Interpreter."

You say I'm belittling this book's true value because GoF said, "Our contribution is to give these programming techniques names. This allows a common language for programmers." If this is a contribution, I could write a book and give names to "air," "water," "pork" and other things, giving everyone a "common language." Isn't that ridiculous? I'm not your personal assistant, Peter Norvig made a speech in 1998 pointing out that most GoF patterns are "transparent" in dynamic languages, meaning you don't feel their existence. However, Norvig's viewpoint is correct but with a caveat. Norvig's understanding of "static languages" is limited. Some static languages can pass functions as arguments, unlike Java requiring everything in a class. Such static languages can also avoid most GoF design patterns. However, the term "dynamic language" in programming theory isn't clearly defined. Dynamic languages can indeed perform certain "static type checks." In 1998, I was still a clueless kid, so I didn't argue with Norvig about it.

Given that elders have historical limitations, why do I pick on GoF? This book is old, and if no one is being misled by it anymore, this blog post wouldn't exist. But when I was interning at Google, I found that almost every programmer had a copy of GoF on their shelf. During my first stint at Google, I wrote all the code myself, so I didn't use any GoF design patterns. The code was straightforward and elegant. However, when I returned to Google, I found that my code had been infused with factories, visitors, and so on. It didn't accomplish much, but it made my code convoluted and hard to understand.

A bad book doesn't just harm one generation of programmers. In light of this, I felt compelled to write this post. Dear novices, I implore you to sound the alarm, don't walk down this old path, and write code that causes suffering to others.