---
layout: post
title: "practical-idealism"
---

I'm not an idealist as some people may think. A person once read my article and assumed I was an "idealist," so they approached me to chat. They said, "You know, I'm just like you, I love simple and elegant code. Last time I worked at a company, I saw their code was a mess, I didn't say anything and just rewrote it, but a few small parts were different from the original, and later the system crashed because of it. The boss told me not to come to work the next day! Do you think I'm a good Samaritan or what?"

Although I sympathized with him losing his job, I don't agree with his method of rewriting others' code without consent. In fact, I once worked with someone who loved to rewrite others' code, and the entire team (including me) almost went crazy because of him. So I told him, "You can't change other people's code like that! If I were your boss, I might not have fired you, but I would have given you a serious warning."

From our conversation, you may have already noticed that I'm not the "idealist" that some people think I am. Although I have many innovative and beautiful ideas, they are all deeply rooted in reality. I oppose ideals not based on reality, in fact, that's not idealism, but just daydreaming. My intuition and reason will quickly tell me which things are possible and which are not likely. I can usually detect and avoid "idealistic" methods that will ultimately fail in the early stages.

From my views on various "new languages," "new theories," and "new technologies," you may have already noticed this trait of mine. People who don't understand me might even think I'm "old-fashioned," but I'm just analyzing things rationally and predicting the failure of some "new technologies." In my mind, things and technology have no new or old distinction, only a rational or irrational difference. I'm not going to interfere with other people's "junk code." You might find my approach surprising: I try to avoid touching it as much as possible!

Though I prefer simple and elegant code, when it comes to other people's code, even if it's ugly and chaotic, I won't disturb it. I'm like a heart surgeon, performing multiple "heart transplant surgeries" on existing code. The key to success in this surgery is making as small an incision as possible, just big enough to replace the heart, without disturbing other parts. Even if those areas have tangled blood vessels and are filled with all kinds of garbage, I won't touch them.

Why is that? Because the primary goal of code should be "solving problems" (including "no bugs"), and simplicity and elegance come second. If it can't solve problems, what's the point of being simple and elegant? It's just a toy. As for code that can already solve problems, no matter how complicated or messy it is, I hold it in high regard and would never, without a second thought, delete and rewrite it like that friend did. It's like performing heart transplant surgery on someone and, seeing some tangled blood vessels in their thigh, you cut open their entire thigh. Your patient wouldn't be alive to complain, would they?

When I write code, "solving problems" and "simplicity and elegance" are usually closely intertwined. If I can't write simple and elegant code, I can't both solve problems quickly and accurately. So my code is usually simple and elegant from the start, modular. I start writing from very small functions, each function solving a very small problem, and eventually I combine them to solve the entire problem. I. Regarding other people's code, the situation is quite different. Many people write chaotic and complex code that is hard to understand, giving me a headache. However, due to the fact that they have spent a lot of time on it and the code has been in use for a long time, undergoing various real-world tests, it has already solved the problem. For such code, my experience is this: if you delete it completely and rewrite it, it is very difficult not to repeat the mistakes of the original author. Even if you believe your skills are top-notch and your code is extremely simple and elegant, you cannot avoid errors.

II. This is not an intelligence issue, but a wisdom issue. Those who enjoy deleting others' code and rewriting it may have high intelligence but lack wisdom. Code is used to solve real-world problems, and the real world is full of intricacies. These imperfections may come from library code, the operating system, network protocols, user habits, or even nature. We must acknowledge that we cannot change many of these things, as we lack the ability, time, or necessity to do so.

III. The code has already been written and used for several years. It has likely encountered various real-world problems and edge cases, and the original author, although not as clear-thinking as you, has invested time and energy into it. The complex and disorganized code logic contains solutions for the imperfections of the real world. A wise person must be able to leverage the chaotic code left behind by predecessors, as it contains the wealth of time-accumulated knowledge.

IV. So, how do I usually utilize the legacy code left behind by others? My strategy includes several key points.

First, I try to keep other people's code as is. Since the problems that their code solves may not be the problems I currently need to solve, changing their code distracts my focus and may introduce new bugs, causing bugs to appear in both old and new code, making it difficult to trace and fix. To keep other people's code as is while writing my own simple and elegant code, I must understand the interfaces (interfaces) and various characteristics of their code and strive to keep them unchanged. This is like a heart surgeon performing a heart transplant, ensuring that all existing blood vessels are connected correctly. I prefer making my own code modular and interchangeable components that can be easily inserted or removed in the system. When I find issues, I can switch back to the old code and retest, determining if the problem lies in the old or new code. I also avoid renaming existing functions, keeping changes limited to a few files, and ensuring Git history remains clear. Even if I need to rename, I should do so as a separate commit, not mixed with logical modifications.

If through multiple trials, I find someone else's code needs changes for me to continue writing new code, I must modify it. Given the complexity and chaos of existing code, I approach it with great care. I don't delete large chunks of code and start from scratch, as this is almost certain to fail. Instead, I isolate a small piece of code and rewrite it. Immediate testing and experimentation follow, with the original author checking for issues, and so on.

How small should the code change be? I might only rewrite a for loop, extract a few lines into a helper function, simplify an expression, make a class member into a local variable, or change a few local variable names. You can refer to the various ways of improving code mentioned in "The Wisdom of Programming." Every such small change carries the risk of error, necessitating rigorous verification to ensure the modified code retains the same semantics as the original. Through repeated testing, you can correctly replace the old code.

From my approach to other people's code, you might have noticed I'm not an idealistic dreamer. I don't completely reject and rewrite other people's code for the sake of my simple and elegant ideals, knowing the complexity of the real world. My attitude towards other people's code is deeply rooted in reality. By employing meticulous measures, I ensure the improved code retains the same semantics as the original, minimizing the repetition of past errors, and avoiding introducing new bugs.

Rooted in reality, I call myself a "practical idealist" rather than an "idealist." I've worked with pure idealists who criticize others' code as ugly and indiscriminately delete and rewrite large amounts of code, resulting in disastrous consequences for the development team. I will avoid working with such people in the future. thin this example, you might have discovered why "practical idealism" is superior to "idealism." I'll explain why "practical idealism" surpasses complete "realism" next.

### Beyond Realism

If I'm not a complete idealist, does that mean I'm a complete "realist" then? Throughout my professional career, I have proven multiple times that I'm not a complete realist, as I can do things that realists cannot. The "ideal" component in me allows me to see possibilities that realists cannot, while my "real" component helps me find practical solutions for these possibilities. The combination of ideal and real leads me to achieve targets that realists deem impossible.

The first example that comes to mind is the project I completed at Google years ago. Google required a tool capable of indexing Python code like an IDE, supporting accurate "go to definition" functionality. Steve, the pragmatic leader of our team, instructed me to use an open-source Python tool like PyDev and modify it to fit into our architecture.

After researching over ten open-source Python tools and IDEs, I found that none could accurately implement "go to definition." Their implementation methods were primarily based on string matching, resulting in definitions that were off the mark and even highlighting names within the string. My idealistic side told me that accurate definition search was possible; it was just that existing tools didn't know how to implement it. To provide precise definition indexing for languages like Python, which is a dynamic language, required type inference, and this was something I excelled at. Consequently, I decided to create a new Python type inference engine, enabling the implementation of precise jump functionality. I shared this idea with Steve and other team members, and as pragmatists, they were very concerned that the project couldn't be completed within the three-month internship period. Steve said, "You know that writing a Python parser alone would take three months. I'm really worried you won't be able to finish the task!" At that moment, my practical side took over. I said, "You know what, I don't think writing a Python parser is a difficult task, but I also don't think it's a meaningful one. So I'll use an open-source parser and generate its syntax tree, then complete the required functionality on top of it."

I ended up using the Python parser from Jython and implemented PySonar on it. The entire process of dealing with the parser took me only two days, leaving me with ample time to explore and implement the most crucial and interesting parts. I took advantage of someone else's work and added my core ideas to it, ultimately achieving the desired outcome. In the end, I not only completed PySonar within the three-month timeframe but also integrated it into the Grok project.

In this example, the pragmatist helped the pragmatist, making the impossible possible. Initially, the Grok project at Google was on the brink of extinction. The success of PySonar increased the project's influence, allowing the team to survive at Google and gain the company's attention. Today, PySonar continues to provide high-quality indexing services for Google's Python programmers, with its data quietly supporting internal code search services like CodeSearch.

### Personal Interest vs. Corporate Interest

Lastly, I'd like to share a related story that highlights how pragmatism is not only personal wealth but also corporate wealth. Pragmatists don't have any conflict with "corporate interest," and in many cases, they can even help or save the company and the team. This story is interesting, but the technical parts in the middle are quite strong, so feel free to skip them if you don't understand.

During my time at Google, I was part of a team working on a search engine for internal code. Our goal was to help developers find the code they needed more efficiently. However, we faced a significant challenge: the codebase was massive, and the search indexing process was slow and resource-intensive.

One day, while browsing open-source projects, I stumbled upon a Python library called "PySonar." It was a static code analysis tool that could parse and analyze Python code. I was intrigued by its potential application to our search engine problem. I shared my idea with my team, but they were skeptical. They believed that developing a code search engine from scratch would be too time-consuming and resource-intensive, given our tight deadlines and limited resources.

However, I saw an opportunity to leverage PySonar and adapt it to our needs. I spent a few days studying the library, learning its inner workings, and identifying how we could modify it to suit our search engine requirements. I proposed my plan to the team, and after some deliberation, they agreed to give it a try.

The process of integrating PySonar into our search engine was a success. It significantly improved the speed and accuracy of our code search results. The team was thrilled with the outcome, and our project gained more visibility within the company. The success of this integration not only helped us meet our project goals but also paved the way for further improvements and innovations.

This story illustrates how the pragmatic approach of leveraging existing solutions and adapting them to specific needs can lead to significant benefits for both individuals and corporations. By combining the power of an open-source tool with our team's expertise and creativity, we were able to create a valuable resource that not only met our project objectives but also contributed to the overall success of our team and the company. I once worked for a company that invited a certain "expert" to become VP. After some time, I discovered this person didn't understand many things and was merely giving orders randomly. It was clear that they didn't have the company's interests at heart. One day, they proposed a "new idea" - our team's code should implement "module management" by dividing the code into 30 "modules," each as a separate Git repository, connected through Maven's version dependency. Each person was responsible for one or two modules, using "semantic versioning" (semver) to tag module versions. If the code was changed, the corresponding version number was updated, forcing dependent code repositories to do the same, or they could continue using the old module code.

This idea was not discussed or researched collectively by the team, but was implemented by the VP's confidant overnight. We woke up to find our codebases split into over 30 repositories with a series of regulations to follow. I soon found I couldn't work. More than half my day was spent dealing with semver headaches. You'd work for hours, only to find other modules' version numbers had been updated! You'd have to check which codebase had changed, update your Maven files, and test and commit your code again. Sometimes, someone would incorrectly tag a version number and submit the code, causing the project to build failure.

This so-called "modularization" wasn't true modularization. Semver versioning wasn't any better than Git hash. Modules should be logically structured, not based on directory structure, and there should be no circular dependencies. Semver wasn't meant for this purpose, it could only be used to reference library code. Every Git commit hash was a "unique universe" version number, containing the code's unique state. Git naturally solved the "module" version dependency problem. Splitting the code into 30+ Git repositories and using semver to connect them was unnecessary and severely damaged development efficiency.

I sent an email to the team explaining my concerns and the problems this approach caused. A senior engineer from France agreed and complained about spending over half his time dealing with these version numbers. However, the VP insisted their "innovation" was valuable, saying "Any great innovation faces resistance from the old power. Comrades, difficulties are temporary, adaptation is necessary!" We argued about this in emails for two weeks. Despite our logical arguments and evidence, the VP, relying on their power and reputation, refused to back down.

In the end, I took practical action. I wrote a Python script that used Git's lesser-known commands to merge multiple Git repositories into one, preserving all commit history information. With this script, I could create a merged repository at any time. I shared it with the team, telling them I could merge the codebases anytime, and provided them a merged repository for testing. They found the issues were resolved, and several team members adopted my repository. I have proven the impracticability of so-called "modularized code management" through theory and concrete evidence. By observing other companies' code, we found that Google's Chrome project, with over three hundred million lines of code, is all stored in one Git code repository. This shows that a Git code repository is capable of managing Chrome's massive project. Our team, with less than twenty members and fewer than ten million lines of code, was forced to split into over thirty code repositories. This is absurd.

After gaining the consensus of all engineers and the support of our team director, I merged the thirty code repositories using scripts, ending everyone's suffering. However, the VP's confidants were not satisfied and intentionally increased the complexity of the merged codebase, making us dependent on their "tools." I won't go into detail about this. In the end, the VP's reckless commands wasted a significant amount of time and energy for the team and even the entire company, which could potentially lead to its downfall.

I have encountered many so-called managers who prioritize their own careers over the company's interests when they join a new company. They don't make decisions for the company's development and success but for their own "career advancement." These managers understand that a company is like a ship, and they appear to serve the company while actually using its resources to achieve their goals. By squandering the company's resources without making substantial contributions, they may eventually sink the ship. However, as a manager, they can always jump to another ship before it sinks, using their network of relationships to find high-paying positions.

There are many such examples. To help the team and the company reach their goals, I have often taken on pressure and helped them avoid unnecessary waste, even risking my own position. However, the team often goes down the wrong path, and I, who can see clearly, am suppressed and have no say, so I can only watch and do nothing. I am talking about "corporate interests" here, not that I enjoy being a servant to capitalists. The "company" and "enterprise" here represent the collective, including all employees and shareholders.

From this example, you can also see my characteristics as a "realistic idealist." This VP can be considered an "idealist," as he came up with a "novel" and unprecedented way of working, which resulted in disaster for everyone. I analyzed the absurdity of this approach from a realistic and rational perspective, argued for the rationality of tradition, and maintained the interests of the team and the company, with the support of the majority of professional engineers, we ultimately defeated the VP's reckless commands, reversed the damage, and avoided catastrophic consequences. I received this email from a team member when I left the company:

He said, "Thank you for helping us maintain reason and sanity, pushing our business forward. We will remember you!"

Such a realist idealist, whether as an employee, a team leader, or a company commander, will put it into practice and bring help to them, preventing unnecessary waste and detours, guiding the enterprise onto the right track, and toward prosperity. I hope that the vast number of IT workers can understand what I am saying here, root their "great ideals" in reality, and avoid deviating due to their own impulsiveness.

If you find this article helpful, please consider voluntarily purchasing it for ￥30.