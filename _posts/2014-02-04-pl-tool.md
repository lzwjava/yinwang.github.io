---
layout: post
title: "PL Tool"
---

I've talked about various programming languages at length, making it seem like the quality of a language is solely determined by the choice of it. However, there's a question I haven't addressed yet: the design of "programming languages" and "programming language tools" are two different matters. A great programming language may lack excellent supporting tools due to the designer's oversight or time constraints. Conversely, a less-than-ideal programming language may have people invest significant effort into creating tools for it, resulting in significant improvements in usability and programmer productivity.

As I've mentioned before, a programming language is not a tool itself; it's like wood, nails, and glue. If a company produces excellent glue with high adhesiveness but poor packaging that makes a mess when opened, would you choose that glue over a slightly less effective one with good packaging, easy application, and easy storage? Most people would opt for the latter, unless the less effective glue's adhesiveness is truly insufficient.

This is why, despite my admiration for Scheme, I didn't use Scheme or Racket to construct PySonar or RubySonar, nor did I choose Scala and Clojure. Instead, I went with the "infamous" Java. The maturity and agility of Java's tools were crucial factors, as it's hard to imagine creating PySonar within three months without Eclipse or IntelliJ. I managed to create RubySonar in a month, with a significant contribution from IntelliJ. These IDEs' navigation features allow me to freely traverse the code, while their refactoring features enable me to temporarily name variables without worrying about naming conflicts, making future renaming a breeze. Additionally, I frequently use these IDEs' debuggers to easily locate bug causes. PySonar2 became quite slow, but I couldn't identify the issue's location. I eventually found the problem using JProfiler's trial version. If this issue had been in Scheme code, it would have taken considerable effort to find it, as Scheme lacks tools like JProfiler.

However, this doesn't mean learning Scheme is without merit. Quite the opposite; Scheme knowledge is invaluable. A programmer who only knows Java wouldn't be able to write the Java code I produce, even though it looks like Java. The Scheme knowledge I've acquired not only helps me understand how to use Java effectively but also reveals how Java was created. I know Java's strengths and weaknesses, enabling me to make informed choices. My code doesn't rely on any "Java design patterns," and I didn't resort to obfuscating reloads.

In my spare time, I've been designing and implementing my own language (temporarily named Yin). Its implementation language recently switched to Java. Yin's syntax is similar to Scheme, making it seem like a natural fit for Scheme or Racket. However, Racket has an issue that frustrates me, causing me to question whether I could successfully implement my language using it. This issue is that when an error occurs in Racket, it doesn't tell me the specific line number of the error code, let alone make the reason clear. I often see such error messages:

"Function call with incorrect number of arguments"
"Variable a is not defined, located at loop"

It only says function call, but it doesn't mention the name of the function. It only says loop, but there are so many loops in the file, I don't know which one it is. The error messages usually contain a lot of garbage information, pointing to some file in the Racket system. Sometimes copying the code into DrRacket helps find the location, but often even DrRacket doesn't work. Every time I encounter these issues, my thought process is disrupted for a long time, resulting in a decrease in code quality.

Other Scheme implementations also have similar problems, such as Petite Chez, which is even more severe. Only the commercial version of Chez Scheme is better, so this is not just a small criticism. This indifference to tool design is common in the Lisp and Scheme functional programming community. Whenever someone complains about their confusing error messages, lack of debugger, or lack of basic static checks, hardcore Schemer's would mock you by saying: "Aziz is right, I've never debugged because I've never written bugs." "Functional programming in Lisp and Scheme is different from ordinary languages. You need to debug the small pieces of code first and find the problems, then combine them." "When the program has a problem but you can't find where it is, it means your thought process is disorganized, so just rewrite it from scratch……" I'm speechless, geniuses are supposed to be portrayed like this :): Besides pride, another important reason Scheme does not provide error locations is due to its macro system. Since Scheme's core is very small and designed to be extensible into various different languages, most of the code is actually macro-expanded. Due to Scheme's macros being able to contain very complex code transformations (much stronger than C macros), if the expanded code encounters an issue, it is difficult to trace back to the code written by the programmer. Even if found, it is hard to explain what the code originally was, as the compiler sees only the code after macro expansion. If the implementer did not save the original location information, there is no way to find it. This issue is somewhat similar to some C++ compilers giving error information for template code.

: This problem is not just an issue of language designers' attitudes, but also a design problem with the language itself. I think Lisp's macro system is an unnecessary thing, causing more trouble than benefits. A language should be something to use, not something to extend. If even the most basic error messages cannot be accurately located due to this, what is the significance of extendability? A well-designed language should basically not need a macro system. Therefore, Yin's language syntax looks like Lisp, but it will not provide any macro capabilities. Moreover, due to the above experiences, Yin language has made efforts from the beginning to facilitate tool design.