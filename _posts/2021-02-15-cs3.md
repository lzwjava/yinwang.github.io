---
layout: post
title: "cs3"
---

Computer Science Fundamentals Class (3rd Period) Registration

(The registration for the 3rd period class has closed and teaching has begun. Students interested in the 4th period can send applications for early interview, but it will take two months before it starts. You may also consider the recently initiated reading class.)

Computer Science Fundamentals Class (2nd Period) Summary

The 2nd period class reduced tuition fees and expanded the course scale. Although it alleviated the financial burden on students and attracted more participants, it made the workload for me and the teaching assistants quite heavy. I have a different teaching approach from regular schools, not only in terms of content and teaching methods, but also in carefully designed exercises. Exercises are an important part of teaching, helping students improve their abilities, primarily achieved through sequential and progressive exercises. Just like well-designed fitness workouts, they gradually make students' minds stronger, rather than making them abandon halfway or get hurt.

Each exercise is submitted individually, not all at once. This allows students to receive accurate and timely feedback, preventing repeated errors. For exercises with unclear thinking, they receive customized precise suggestions, helping students identify errors, get back on track, without revealing the final result. This design maximally trains students' thinking, gradually giving them independent thinking abilities.

For students' exercises, my requirements are not only correct but extremely simple, with nothing unnecessary, logical, clear, and adhering to the highest standards in blank spaces and formatting. Each exercise may be required to be revised multiple times before passing. Starting from the smallest program, students cultivate the habit of logical thinking from the beginning, maintaining this habit even in complex code, resulting in few programming errors. From this course, students naturally master the aspects mentioned in my "The Art of Programming" article. Few universities correct and guide students in this style, but this is crucial. This is why so many PhDs produce complex and error-prone designs.

I have built a "tutoring group" for each student, consisting of four people: the student, the teacher, and two teaching assistants. This design allows students to receive maximum feedback. Even if the teacher is busy with other matters, the teaching assistants can respond. If the teaching assistants are unsure, the teacher will personally check. So, although it's a group class, each person effectively receives one-on-one teaching.

Compared to university situations, professors and teaching assistants are only seen during lectures or office hours. Homework is submitted and graded once, with little feedback and guidance. This special teaching method significantly improves time utilization efficiency. Each post-lecture exercise becomes teaching itself, so although there are only 8 classes, the actual teaching time is significantly more than lecture time. Most of the time is spent by students working, and teachers only need to intervene at critical moments. I find this type of practice so interesting that by the later classes in the second period, students wished I spoke less and gave fewer hints, allowing them to think through more knowledge points on their own. This teaching method and its results are unprecedented in my career, possibly unique in the world. I have attended four universities in China and the US, and no course or book I have taught has been this sparse, yet students have learned so much.

Though effective, the increased workload for answering student exercises was substantial. During many days of the second period, my teaching assistants and I were still replying to student exercises at midnight. Since many students worked during the week, most began their exercises only on weekends, resulting in a flood of exercise information during the weekends. I have two very dedicated and enthusiastic teaching assistants. Sometimes, seeing them still working late at night and on weekends to reply to students, I would call them to rest. The teaching assistants reported that though they had set their WeChat to "do not disturb," they couldn't help but look at and reply to students' exercises when they saw them. In today's world, there are probably few who care so much about teaching.

### Third Period Registration

Due to the fees and student numbers in the second period, teaching became quite taxing, so the third period course will not adopt the second period's fee price and class size. The specific plans for the third period course are as follows:

1. Adjust the tuition fee back to the original 12,000 RMB, and it can be paid in US dollars.1. Class size limit is within 15 people.

2. Lecture hours still remain 8 classes, each class approximately 2 hours. However, I found that a few classes have less content, thus some classes might be replaced with practice sessions.

3. Due to the unclear effectiveness of discussion sessions and potential occupation of students' working hours, weekly discussion sessions will no longer be held.

4. Considering the dedication of the two TAs in the second period, they will not be asked to be TAs this time. There might not be any TAs, but if there are outstanding students who volunteer, they may be considered.

5. Class times are usually scheduled between 8 pm and 10 pm on certain weekdays. Since it involves many people, class times will not be changed due to individual work schedules. The course does not provide recordings, so students are advised to consider their work schedules carefully, as missing a class may have significant consequences. 7. The course will begin after Chinese New Year, after we have screened applications and reached the class capacity.

### Application Process

To apply, please send an email to yinwang.advising@icloud.com (please do not send emails with other topics to this email). The subject line should be "Computer Science Fundamentals Class (3rd Period) Application." In your email, please include your basic information and attach a resume. Due to limited class size and the importance of the course, we will carefully select applicants. Similar to applying to foreign universities, please write a "personal statement" explaining your motivation for learning. Your attitude determines whether you will be offered the course, so please be serious and thoughtful in your application. Do not rush or be casual. If we find your application suitable, we will notify you for the next steps of the interview.

### Course Outline

Based on the experience from the second period, I would like to provide a more detailed explanation of the course content. Previously, I did not provide much information to leave room for students' creativity and to create a sense of curiosity. However, such a simple explanation may give the impression that "I have already learned these things," and sometimes students find that they think they already understand the course content based on the description. I feel sorry for them.: Here's a brief description of the course content:

Teaching Language. The course currently uses JavaScript as the teaching language, but it's not about teaching JavaScript itself. The course's ideas don't depend on any JavaScript features, making it applicable to any language. The course can be switched to any language at any time. Students start from scratch and learn the core concepts of computer science, creating various important concepts until the end, resulting in their own programming language and type system.

Course Intensity. The course design is a gradually increasing difficulty, challenging but safe path to a high peak. To join the course, please prepare to put in effort. In two months, you need to spend at least one hour every day on practice, and some exercises may take several hours. Unlike other computer science teaching, students won't abandon the course due to a lack of foundation, won't get lost, or fall into traps. Students need to invest a lot of time and effort, but without effort, it's a waste.

Once or twice, there were students who underestimated the learning intensity and had other important tasks, resulting in being unable to keep up. So, please make a reasonable schedule, don't join learning while having other important tasks.

First Lesson: Functions. Unlike general courses, I don't start with a "Hello World" program or ask students to do seemingly fun but actually tedious small games. Instead, I start with the most fundamental concept: functions. There are only a few knowledge points about functions, but they are the core of everything. Practice these concepts repeatedly to make your brain comfortable with them, enabling you to think and transform them easily. I've designed appropriate exercises for each concept. 1. The exercises for the first lesson are simple, requiring only a few lines of code, yet they contain deep principles. The exercises gradually increase in difficulty, surpassing the level of doctoral courses. I changed the terms to avoid students searching related content online, to ensure their thinking is independent and unbiased. The exercises form a system, each linking to the next. The later exercises require inspiration from the earlier ones, but not other prerequisites. Interestingly, with proper guidance, many students have completed the most difficult exercises, even those with no prior knowledge. I won't disclose the specific content.

2. Recursion. Recursion is arguably the most essential concept in computer science (or mathematics). Starting from the simplest recursive function, I guide students to understand the essence of recursion, mastering the systematic thinking approach. Recursion is a concept many believe they understand, but in reality, have been misled by incorrect teaching methods. Many mention recursion only in relation to "Tower of Hanoi" or "Eight Queens" problems, yet unable to apply it to real-world issues. Many programming books superficially emphasize recursion's "drawbacks" and teach students how to "eliminate recursion," yet fail to address the root cause—early implementations of function calls in certain languages (like C) were incorrect and inefficient, leading students to avoid recursion. Due to a lack of clear understanding of recursion, they struggle when encountering complex recursive functions in their future careers.

3. Linked Lists. Starting from scratch, students implement the most basic data structure without relying on any language features. The first data structure is a linked list, and students will write various functions to operate on linked lists during exercises. These functions have been carefully selected and arranged, many of which are fundamental functions in functional programming languages. By independently writing them out, students grasp the recursive systematic thinking approach. This enables them to think freely about these data structures and solve new recursive problems.

Unlike typical data structure courses, this course focuses on implementing "functional data structures," which have unique, useful properties. Their logical structure is clearer than that of traditional data structure books, making them easier to understand. Unlike the teaching style of the Haskell community, I don't dogmatically emphasize the benefits of pure functions but objectively help students understand their advantages and discover their limitations. Mastering these structures allows students to easily extend them to non-functional structures, seamlessly combining different programming styles.

4. Trees. Gradually extending simpler data structures, we introduce more complex ones—trees. Trees are one of the most common and essential data structures in computer science, so understanding tree operations is crucial. Our trees are all purely functional. fifth lesson: calculator. After getting familiar with the basic tree operations, implement a relatively advanced calculator that can calculate any nested arithmetic expressions. An arithmetic expression is a kind of "syntax tree." Students will understand the principle "an expression is a tree" from this exercise.

sixth lesson: search structures. Understand how to implement key-value search structures and implement two important search data structures ourselves. Our search structures are also all functional data structures. These structures will be useful in later interpreters and understanding them will deepen and solidify that knowledge.

seventh lesson: interpreter. Using the foundation we have laid, implement a calculator in computer science, the most important and often considered hardest to understand concept - an interpreter. An interpreter is the key to understanding various computer science concepts, such as programming languages, operating systems, databases, network protocols, web frameworks. The CPU, the core component of a computer, is actually just an interpreter. Understanding interpreters will help you understand "computer system architecture," the hardware. You will find that this hardware is not very different from software. An interpreter is just "computation itself," so it is worth studying. A deep understanding of interpreters will also help understand various other subjects, such as natural language, logic.

eighth lesson: type system. On the foundation of the interpreter, students will understand and implement a relatively advanced type system (type system) and type checker (typechecker). This is similar to implementing a static type language like Java, but more advanced and flexible in some ways. Our type system includes the key features of types, not just superficially explaining some type system. When you are not satisfied with the types in existing languages, these thoughts can help you design your own type system. Students will understand the principles of static type systems in a hands-on way, without any formulas.

The rules and implementation of type systems and their types, in general, only appear in doctoral-level research and can be written as a thick book (like TAPL), containing various mysterious logical formulas. My students, however, can master the key parts of this technology in one lesson, implement a correct type system, and derive correct formulas. Some type rules are so subtle that even a large company like Microsoft, in the 21st century, made basic errors when creating a new language (TypeScript). Students who have taken this course can say that their understanding of these fundamental principles exceeds that of the TypeScript designers, but they may not have realized their own strength. about object-oriented. Although the course won't specifically teach "object-oriented" thinking, the essence of object-oriented thinking will be incorporated from the beginning in the exercises. Students who have taken the course later found out that although I never directly taught object-oriented, they had already understood the essence of it. In practical applications later, they can use this thinking to understand the essence of object-oriented thinking and apply it reasonably.

bonus practice. I will supplement other content through "bonus practice" in the process. For example, in the second period of the course, I designed a parser exercise temporarily, which students who had completed other exercises understood the principle of parsing and wrote a simple but logical parser. The bonus practice is called "bonus" because not all students will get this exercise, only those who have put in effort, integrated well in other exercises, and have the capacity to learn more. This encourages students to study more diligently.

If you understand the implications of the above content, you may no longer ask "Can I join the advanced class since I have learned all of this?" because few people truly understand these concepts. Even the world's most advanced programmers and university professors have unclear areas regarding these. I have also been inspired by teaching these concepts myself.

A friend looked at my course content and said it was not a "beginner's class," but a "master class." He didn't believe that students with no prior knowledge could keep up, but it turned out to be possible. Why can't it be both a "beginner's class" and a "master class"? As the saying goes, a master is just someone who understands the fundamentals deeply. I hope this beginner's class can help people gain a deep understanding of fundamental principles, enabling them to see through many other contents. After joining the "beginner's class," they may not need an "advanced class" for a long time because they have acquired strong self-learning abilities and can explore the unknown world and climb higher mountains on their own.