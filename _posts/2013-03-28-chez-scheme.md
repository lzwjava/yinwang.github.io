---
layout: post
title: "chez-scheme"
---

I mentioned in the last blog post that there were issues with Lisp compilers. In the early days of Lisp, due to the increased expressiveness of constructs like function as value passing, people didn't know how to implement efficient compilers for it. Many Scheme compilers actually compiled Scheme to C and then used C compilers. GHC, Haskell's compiler, was also like this in the early days. Furthermore, due to the generated assembly code from C compilers not fully meeting Haskell's requirements, GHC contained a Perl script specifically for adjusting the structure of this assembly code, which was called the 'evil mangler'. This has been removed now, but its existence shows that the technology for functional compilers was quite chaotic in the early days.

In my opinion, the main problem with early Lisp compilers was a lack of understanding of the essence of compilation and the fundamental difference between compilers and interpreters. Interpreters are slower than compilers most of the time because they ask too many questions. Every time they encounter a construct, they ask: "Is this an integer?" "Is this a string?" "Is this a function?" ... and then perform different actions based on the answers. These questions, in compiler theory, are called 'interpretive overhead'. The essence of compilation is to perform 'static analysis' on the program before it runs, trying to answer these questions once and for all. Therefore, compiled code doesn't ask these kinds of questions, it already knows what construct will appear at a given location and what should be done, so it just goes ahead and does it. Early Lisp compilers, as well as many current Scheme compilers, had issues because they didn't cleanly eliminate these questions or even eliminate them altogether. I discovered Scheme had numerous "implementations" when I first learned the language: PLT Scheme (now called Racket), MIT Scheme, Scheme 48, Bigloo, Chicken, Gambit, Guile, etc. I couldn't tell which one was better. Some Scheme implementations seemed more advanced, but in practice, I always felt uneasy because I wondered if the compiled code would compare to C language code. This is why I eventually started using Common Lisp, as it seemed to have quite a few efficient compilers (CMUCL, Lispworks, Allegro, etc.).

I eventually found Chez Scheme, which changed my understanding of Scheme compilers and the entire concept of compilers. At the time, I only downloaded the free version of Chez Scheme, called Petite. Petite was different from the official Chez Scheme version in that it didn't output binary code, so you couldn't sell the compiled code. Additionally, due to commercial purposes, Petite's error messages were very "minimal," making it necessary to use other Scheme implementations to find bugs' locations. However, once it was run, it was clear that Petite, which directly executed Scheme code as an interpreter, was much faster than other Scheme implementations' compiled code.

Chez Scheme changed the course of my life, and I never imagined I would meet its creator, R. Kent Dybvig, and become his student. I can only say that perhaps it was all destiny. The first time I met Kent, he quietly told me, "You should own your code. One day, you'll find its value."

This Kent, a lone gunman, created Chez Scheme, the world's only commercial Scheme compiler, and established his own company (Cadence Research Systems). Chez Scheme's price was not cheap, and its pricing was not transparent. Its price depended on the project's size and the company's scale. Some large corporations purchased Chez Scheme for their core projects. Some corporations even bought the compiler's source code to ensure its security. Kent's company only had him, so he didn't have to worry about management or sales. He lived a very comfortable life, essentially a carefree and indifferent person.

Kent was the most mysterious and cool person I've ever met in my life. He rarely praised or belittled anyone. From his cold, detached language, you could sense he wasn't of this world. Any emotion - joy, anger, sadness, pride, contempt, or flattery - failed to elicit a response from him. He had countless secrets, and you needed some finesse to extract his true words. He rarely published papers but understood other people's papers thoroughly. No one knew his core technology, and he didn't care if others understood his level. Most surprisingly, no one knew his real name! His full name was R. Kent Dybvig, but no one knew which R. was the initial. So, everyone just called him by his middle name, Kent. I. Chez Scheme's "generated code" efficiency is superior to any other Scheme compiler I have seen. Its "compilation speed" is also unrivaled by any compiler (note I removed the "Scheme" qualifier). Chez Scheme can self-compile from source to machine code within 5 seconds. Consider the time required for GCC or GHC, you'll understand the gap.

II. Noteworthy is that Chez Scheme is entirely Kent's solo work. Its functionality is from Scheme source code to machine code, without relying on any other language's compiler. It doesn't even depend on third-party assemblers; all assembly code for Intel, ARM, SPARC architectures are written by Kent himself. Why do this? Because few other compiler codes can meet his standards. Not even Intel's assembly code for its own processors can satisfy his requirements.

III. If you've taken Kent's course, revisit common compiler textbooks (like the renowned Dragon Book) or LLVM code. You'll find that Kent's abilities are indeed above these renowned giants. Why can I say this? If your abilities aren't up to par with these people, you'd question such an assessment. But if you surpass them, their every word, every error, appears under your microscope. This is why one day I picked up the Dragon Book and felt it so simplistic. In reality, it wasn't simplistic, but I had grown accustomed to it. In the compiler domain, I believe Kent is a strong contender for the world's No.1.

IV. If you're unfamiliar with the intricacies of Scheme compilers, you might underestimate its challenges. Scheme is a language far more advanced than C, so its compiler must handle many more tasks. In the first half of Kent's compiler course, we essentially built a C compiler, converting a language based on "S-expressions" into x64 assembly code. In the second half, we introduced advanced Scheme features, such as functions as values (requiring closure conversion and optimization), tail recursion optimization, etc. Additionally, I added a beautiful technique called online partial evaluation. This technique can complete optimizations that a regular compiler requires multiple passes to accomplish in a single pass.

V. Under these advanced optimization techniques, almost all redundant code is eliminated by the compiler. The intelligence of these optimizations surpasses human thinking in many aspects, providing accuracy and depth that humans cannot match. If your program doesn't use Scheme-specific features, the generated code will be similar to C-compiled code. For instance, if your code doesn't pass functions as values, or if your functions don't have "free variables," or if your functions have free variables but you can't change their values outside the function, then the code won't contain "closures," and no unnecessary memory data exchange will occur. Sometimes, you'll even get better code than C programs, as our "backend" compiler is more advanced than GCC, LLVM, etc.: Kent's course compiler has a good structure, called the "nanopass compiler architecture." Each pass does a small task, and these passes are chained together to form a complete compiler. The compilation process involves transforming the input program through a series of changes into machine code. You may have noticed that this is similar to LLVM's structure. However, our course compiler is cleaner and more advanced than LLVM in many ways. In each lesson, we learn a new pass. Each lecture is very precise in explaining what needs to be done. Each assignment is submitted with over a hundred tests (Kent doesn't give us all of Chez Scheme's tests). If it doesn't pass, it will be rejected. These tests can be downloaded for debugging. Interestingly, each assignment requires us to submit some self-written new tests to "break" other students' compilers. So we always come up with cunning input codes to make our classmates' lives difficult. Of course, this is all in jest, and this approach significantly enhances our understanding and interest in compiler testing, as well as camaraderie among students. This is a stark contrast to the compiler course I took at Cornell, which I then dropped.

At the end of the course, we produced a complete compiler that could compile Scheme's essential subset into X64 assembly code, which was then transformed into machine code using GNU's assembler. In the final lecture, Kent gave us a memorable summary of our semester. He said: "The compiler code you're writing now contains many advanced technologies. Perhaps, after some time, you'll look back at this code and discover its value. If you think you've become an expert in compilers, I'll tell you that your fastest submitted compiler is 700 times slower than Chez Scheme. But don't be disheartened, I'll tell you where you can improveâ€¦"

Few people have seen Chez Scheme's source code, and I haven't either. However, those who have tell me that Chez Scheme actually has very few passes, unlike our course compiler with about 50 passes, saving a lot of time spent "traversing" the code tree. Chez Scheme only uses simple algorithms and doesn't employ the complex methods mentioned in papers, which is one reason for its speed. For instance, its register allocation doesn't use the commonly used "graph coloring" method but instead uses a simple algorithm similar to linear scan, resulting in more efficient code. Additionally, Scheme uses S-expressions for its syntax, making syntax analysis very fast. Other languages, due to their complex syntax, spend a significant portion of their compilation time on syntax analysis.

In essence, Chez Scheme had already surpassed human capabilities with its technology, but Kent published fewer papers about it. This wasn't due to selfishness, I suppose. He had already given us such a valuable gift through his course. For deeper insights, I often discovered solutions on my own and then tried to mimic his way of expressing them, only to find that he sometimes had even better ideas. Sometimes I would be surprised by his profound understanding. For example, one day I asked him why compilers need register allocation and why they need registers. I thought that Knuth's MMIX processor design with a "register ring" might eliminate the need for register allocation altogether. He listened quietly and then said, the register ring (as well as SPARC's register window) in MMIX actually has issues. When function recursion calls reach a certain depth, the register ring will run out of registers, resulting in excessive data exchange between registers and memory. Registers that have been pushed onto the stack and are no longer in use, however, are not effectively reused. Thus, I discovered that he not only understood MMIX's design but also saw through its essence.

During the course, I found myself coming up with some inspired methods, which even surpassed Chez Scheme in certain passes, generating more efficient code. However, my compiler code was shorter and less complex (most of the time it was not as efficient as Chez Scheme). I then noticed that Kent would quietly spend time investigating my code to understand how I did it but didn't want me to know. Inspiration and absorption from others, and the ability to incorporate it into one's own skills, might be Kent's secret to mastery. I think, this article should have come to an end by now. The purpose of writing these things is actually to instill confidence in people regarding functional language compilers. They are indeed smarter in some ways than compilers for languages like C and C++. I don't have the time or energy to elaborate on the details of these compilers because they are incredibly complex yet elegant pieces of software. If you're interested, you can check out my last code. Due to copyright reasons, some auxiliary parts I cannot put online, so you won't be able to run it, only see its general shape. If you need a Scheme version for learning, there's a free version of Chez Scheme called Petite Chez Scheme that you can download. However, note that Petite's error messages are very unfriendly, so I also recommend Racket as an alternative. But be aware that Racket's speed is significantly different from Chez Scheme's.