---
layout: post
title: "Giving Java a fair statement"
---


Someone asked me, among existing languages, what would I recommend? I said: "Java." They were surprised: "Java?!" So I'm here to explain.

### Java surpassed all those who curse it as a "static language"

Perhaps it's the rebellious nature of the young, students in computer science used Scheme or Pascal to get started, while most schools now use Java. This might be why many people hate Java, look down on those who use Java. Mentioning Java makes one feel like it's something from the older generation. Everyone uses Java, how can I stand out? So they say: "Java is old, bulky, complex, bloated. I'd rather explore new languages...."

Some Python programmers, in forums, explain to beginners why Python is good, and one reason surprisingly is: "Because Python isn't Java!" They love to promote: "Look how simple and clear Python is, no need to write types...." The unwarranted hatred and blind rejection of Java led them to overlook its significant advantages, causing them to lose their way. Despite its dominant stance, Python as a programming language is actually unable to compete with Java.: In terms of performance, Python is several tenfold slower than Java. Due to the lack of static typing and other essential facilities, Python code has bugs that are hard to find and debug, making it unsuitable for constructing large-scale, complex systems. You may find that some startup companies' main code is written in Python, but the quality of their software is actually quite low. In mature companies, Python is mainly used to write tool-like things or small scripts that won't affect system reliability.

The lack of static typing also means that Python cannot have good IDE support, making it unreliable to "jump to definition" or fully reliable refactoring of Python code. PyCharm is a significant improvement for early Python programming environments, but theoretically, it cannot completely reliably perform basic refactoring operations like variable renaming. Even powerful tools like PySonar are powerless against this. Due to Python's overly "dynamic" design, without type markers, accurate definition lookup becomes an undecidable problem.

In terms of design, Python and Ruby are more complex than Java, lacking many important features while having some problematic "powerful features" instead. Due to blind worship of the so-called "orthodox object-oriented" approach, with "late binding," these languages have many places where things can be redefined, leading to significant uncertainty and complexity in the code, with many bugs hidden in these languages' overloaded structures. Therefore, Python and Ruby code are easily misused, hard to understand, and prone to errors.

Many JavaScript programmers arrogantly dismiss Java, but in reality, JavaScript is even worse. Not only does it share most of their disadvantages, but it also lacks some necessary facilities. The various "Web frameworks" for JavaScript seem to constantly be coming out, but in reality, they're just stumbling in the dark. The JavaScript community is known for its childishness and naivety. You often find that even basic common sense is discovered as if it were a great revelation by "JavaScript experts" at conferences. I don't see the point of these JavaScript conferences; it seems they're just for networking and finding jobs.

Python is just about adequate for insignificant things, Ruby is garbage, and JavaScript is garbage among garbage. The reason is simple: the designers of Ruby and JavaScript were actually half-educated amateurs. Yet, the world is strange; a completely garbage language can still claim to be "programmers' best friend" and gain the affection of some people...: In recent times, many have been infatuated with Scala, Clojure, and Go among emerging languages. They believe these are more modern and advanced languages that will eventually replace Java. However, these zealous followers have gradually discovered that Scala, Clojure, and Go don't actually solve the problems they claim to solve and even introduce their own issues, many of which Java doesn't have. Only then did they realize that Java is still a long way from its demise.

Scala:

Regarding Scala, I have commented on it extensively, those interested can refer to that. In short, Scala is a product of quackery and megalomania, quite bizarre. Here, I won't say more about Go, and will only discuss Scala and Clojure. I know some people who were initially very enthusiastic about Scala, as if it was a savior. I advised them not to mess around with it, and stick to Java instead. They didn't listen to me, and in the end, they spent their days complaining about Scala's various flaws. But what can I do? The project had already set sail, and they had to continue using it. I don't like personal attacks, but I've found that the quality of a language often depends on the background, wisdom, character, and motivations of its designers. My gut feeling about people is usually quite accurate, and based on my first impression of a language's designer, I can predict how it will develop in the future. In this context, I'd like to share my views on the designers of Scala and Clojure.

Martin Odersky, the designer of Scala, has made a name for himself in the PL field, publishing numerous academic papers (including the famous "The Call-by-Need Lambda Calculus"), and he was a disciple of the renowned Niklaus Wirth. Given this background, I initially had high expectations for him. However, I was surprised to find that even some very basic things were designed incorrectly in Scala. This is why I tried to adopt Scala several times, but ultimately gave up. I kept discovering design flaws that made me cringe, and these issues were ones that Java didn't have. Over time, I lost faith in Odersky and my interest in Scala waned.

Looking back at Odersky's papers, I realized that despite their theoretical appearance, they were often full of empty rhetoric (including that so-called "call-by-need lambda calculus"). He may have had some depth of knowledge in specific areas, but his overall knowledge base was limited, and his perspective was narrow. When it came to the holistic design of a language, he lacked a good grasp. It seemed he was forcing together various language features and didn't consider whether they could coexist harmoniously or not, and rarely considered "usability."

Because Odersky was a university professor with a renowned reputation, many people wanted to study under him to earn a PhD, so they indulged in adding obscure, potentially problematic "features" to Scala, just to publish papers and graduate. This led to Scala's inclusion of unnecessary features, making it overly complex. Many of these added features later proved to have little practical use and even caused problems. Students implemented their code into the Scala compiler and left once they graduated, leaving behind a heap of historical legacy code and bugs in the compiler. This may not have been entirely Odersky's fault, but at least it suggests a lack of oversight or questionable taste.

The most well-known companies using Scala are just Twitter. In truth, systems like Twitter could be built using Java just as effectively. So what happened to Twitter? The CEO left :P The new CEO came in and laid off over 300 people, including engineers. I estimate that one reason for the layoffs was the presence of too many Scala developers, who were spouting lofty, yet impractical, programming concepts like "functional programming," engaging in excessive engineering, wasting the company's resources. They spent the company's money on conferences, meetups, and hackathons to boost their influence in the open-source community, but they didn't create much value for the company. I'd like to talk about Clojure again. When Clojure first emerged, some people passionately recommended it to me. I watched a promotional video by its designer Rich Hickey. I was impressed by his charisma, even though he didn't have a CS degree. But only such people can create a "religion," I suppose.

Full of buzzwords like "lazy," "pure," "STM," and claimed to solve "large-scale concurrency" issues, these words were easy to hook people in. However, most of these terms were borrowed from other languages but not fully understood. Some functional language features were problematic to begin with, but were adopted out of ideological purity and to appear more sophisticated. So you find that this language is like a sheep in wolf's clothing, speaking in lofty tones but performing clumsily.

Clojure's community has been busy stealing ideas from Scheme and Racket projects while boasting of their own inventions. For instance, Typed Clojure is a direct copy of Typed Racket. Some basic concepts have been around in Scheme for decades, but they're renamed to avoid discovery. Some people even rewrote the code from SICP and The Little Schemer in Clojure, only to lose the original works' simplicity and clarity. In the end, you find that the good parts of Clojure are already in Scheme, and most of its new features have issues. I've attended some Clojure meetups, only to discover later that they were filled with amateur enthusiasts, self-proclaimed experts, and the naive.

If you're planning to build a system now, it's better to use Java instead of wasting time on Scala or Clojure. A misguided designer created a misguided language, wasting everyone's time. I still don't understand why many people harbor hatred and contempt towards Java. Perhaps it lacks some convenient features, but I have taught, worked, and developed PySonar, RubySonar, Yin language, among others, using Java. I found that Java is not as evil as people say. I found that I can find over 95% of the features I want in Java. The remaining 5%, I can solve with slightly clumsy methods.

Blindly worshippers of Scala and Clojure, many of them eventually found that the "new features" in these languages have flaws, and the most important and useful features are already in Java. Some people tell me, "Java can't do this thing!" After analyzing it, I found that they had a rigid prejudice in their subconscious, insisting on using some latest and cool language features to achieve their goals. Java doesn't have these features, so they think they need another language. In fact, if you change your perspective and focus on solving problems instead of pursuing the latest and coolest "writing style," you can use Java to solve it, and do it cleanly and effectively.

Many people say that Java is complex and bloated, but in fact, it's due to the early Design Patterns that tried to propose a one-size-fits-all template, bringing unnecessary complexity to the program. However, Java itself and Design Patterns are not equivalent. Java's designers and Design Pattern's designers are completely different people. You can write very simple code using Java without using Design Patterns.

Java is just a language. The language only provides you with basic mechanisms. Whether the code is complex or simple depends on the person. Transferring hatred towards some Java programmers who abuse Design Patterns to Java itself, and completely abandoning it, is not wise. Conclusion

I usually use Java with pleasure, and I was originally too lazy to comment on other languages. But I couldn't help but say a few words here since I can't stand seeing some people being deceived by Scala and Clojure. If there's no extreme high performance or resource requirement (you might need a low-level language like C for that), I'd suggest sticking with Java for now. Although it's not as cool as some new languages, in reality, there's not much a system can't be built with Java. There are a few places where you might need to bypass some limitations or relax some requirements, but such situations are not common.

The choice of programming tools is important, but ultimately, the tools are not as important as your own skills. Many people spent too much time experimenting with various new languages, hoping they would miraculously improve code quality, but in the end, they accomplished nothing. The most important condition for language selection should be "sufficiently useful" because a project's success ultimately depends on people, not the language. Since Java doesn't have significant issues that would prevent you from completing a project, why try some unreliable new languages?