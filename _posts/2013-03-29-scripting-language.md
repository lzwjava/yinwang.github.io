---
layout: post
title: "What is a "Scripting Language"?"
---


Many people use some "scripting languages" (scripting language), but few really understand what a scripting language is. People use shell to write some "scripts" to complete daily tasks, use Perl or sed to process some text files, and many companies use "scripts" to run their "builds" (called build scripts). So, what is the difference between a "scripting language" and a "non-scripting language"?

In fact, there is no semantic or execution method difference between "scripting languages" and "non-scripting languages". The difference lies only in their design intentions: scripting languages are designed as a temporary "patch", and their designers did not consider making it a "general-purpose programming language" or building large-scale software. These designers were often not professionally trained and did not fully understand the fundamental concepts of programming languages. Conversely, "non-scripting" general-purpose programming languages are designed by experts or a group of experts from the outset, considering "generality", reliability, and scalability in large engineering projects.

First, let's look at the concept of "scripts". Users of Unix systems often enter some commands, which seem to be "one-time" or "disposable". However, people soon found that these commands were not as "one-time" as they seemed, and they were actually repeatedly entering similar commands. So, someone invented "scripts" for this purpose. Its design intention was "batch processing" of commands, where you put all the commands in a file and then execute the file. However, people soon found that these command-line constructs could be constructed more intelligently, such as defining variables or executing different commands based on system types. So, people added variables, conditionals, arrays, and other constructs to scripting languages. "Scripting languages" were thus born.

However, people did not realize that they didn't really need scripting languages. Because the structures in scripting languages exist in any "serious" programming languages (such as Java, Scheme), and they are designed more perfectly. Therefore, scripting languages are often reinventing the wheel, and even the wheel design is not good. The early advantages of scripting languages may only be in not requiring prior "compilation" and seeming to save a few characters when calling programs. Scripting languages may have some value for languages like C. However, compared to Scheme or Java, this advantage is not very obvious. For example, you can completely imagine an automatic way, write Java code first, then call the Java compiler, then call the JVM, and finally delete the class files. Or you can choose a "formally interpreted" "serious language" like Scheme. Many people mistake Scheme for a "scripting language" due to its ability to interpret and execute like one. however, Scheme is actually more "serious" than C and Java. Scheme was designed from the start as a "general-purpose programming language," not for simple, singular tasks. The designers of Scheme had more experience than the designers of Java, making them well aware of Java's design flaws. Compilers like Chez Scheme have been able to compile Scheme into efficient machine code for a long time. In fact, many Scheme interpreters also perform some level of "compilation," compiling to bytecode or machine code before execution. Therefore, in this context, the distinction between "compiled languages" and "interpreted languages" is virtually non-existent, as the "interpreter" is simply an automated compiler and executor.

Unlike Java or Scheme, "scripting languages" generally imply poor design, with their design goals being shallow-sighted. These languages are filled with historical hacks and have little to no "principles." Unix's shell (such as bash, csh, ...) is usually of this type. Java has its issues, but it is a world apart from "scripting languages." However, in today's engineering projects, scripting languages occupy a position they should not. For example, many companies use shell scripts to manage the entire software "build" process or testing process, which is a misguided decision. Once these shell scripts expand, they become extremely difficult to control. Odd problems frequently arise, but finding the source of the problem is challenging. Linux uses shell scripts to manage many startup projects and system configurations, which is a historical mistake. So, don't be fooled into thinking that shell language is something good just because you see Linux using so much shell scripting.

If you use typical programming design principles, such as functions, in your shell script, a few hundred lines of script may not become unmanageable. However, I have found that many people, who have clear programming design principles in their minds, completely collapse when faced with "scripting" tasks. They seem to believe that writing scripts means they should be "loose." Many intelligent programmers, when faced with "system administration" tasks, write shell scripts or Perl scripts. They forget the basic principles of programming, such as "modularity" and "abstraction." They heavily rely on "environment variables" to transmit information and forget to use functions. They apply temporary patches everywhere, only caring that there are no problems at the moment. Later, they spend a lot of time dealing with the hassles caused by the scripts, but they never find the root cause, which is their mistaken belief that they need a "scripting language" and that writing scripts means they should be "loose."

Therefore, I believe scripting languages are a curse. They are almost always the wrong decision. We should try to avoid using scripting languages as much as possible. When there is no alternative (like when the boss insists), we should use as many typical programming design principles as possible in the script.